settings:
  # Custom monitor definitions to add to Node Problem Detector - to be
  # mounted at /custom-config. These are in addition to pre-packaged monitor
  # definitions provided within the default docker image available at /config:
  # https://github.com/kubernetes/node-problem-detector/tree/master/config
  # settings.custom_monitor_definitions -- Custom plugin monitor config files
  custom_monitor_definitions:
    oke-gpu-ecc.json: |
        {
        "plugin": "custom",
        "pluginConfig": {
            "invoke_interval": "300s",
            "timeout": "30s",
            "max_output_length": 80,
            "concurrency": 1,
            "enable_message_change_based_condition_update": false
        },
        "source": "oke-gpu-ecc.json",
        "metricsReporting": true,
        "conditions": [
            {
            "type": "GpuEcc",
            "reason": "GpuEccHasNoIssues",
            "message": "No ECC issues detected with GPUs"
            }
        ],
        "rules": [
            {
            "type": "permanent",
            "condition": "GpuEcc",
            "reason": "GpuEccHasIssues",
            "path": "./custom-config/oke_healthcheck.sh",
            "args": [ "gpu-ecc" ],
            "timeout": "30s"
            }
        ]
        }
    oke-gpu-remap.json: |
        {
        "plugin": "custom",
        "pluginConfig": {
            "invoke_interval": "300s",
            "timeout": "30s",
            "max_output_length": 80,
            "concurrency": 1,
            "enable_message_change_based_condition_update": false
        },
        "source": "oke-gpu-remap.json",
        "metricsReporting": true,
        "conditions": [
            {
            "type": "GpuRowRemap",
            "reason": "GpuRowRemapHasNoIssues",
            "message": "No Row Remapping issues detected with GPUs"
            }
        ],
        "rules": [
            {
            "type": "permanent",
            "condition": "GpuRowRemap",
            "reason": "GpuRowRemapHasIssues",
            "path": "./custom-config/oke_healthcheck.sh",
            "args": [ "gpu-row-remap" ],        
            "timeout": "30s"
            }
        ]
        }

    oke-gpu-bus.json: |
        {
        "plugin": "custom",
        "pluginConfig": {
            "invoke_interval": "300s",
            "timeout": "30s",
            "max_output_length": 80,
            "concurrency": 1,
            "enable_message_change_based_condition_update": false
        },
        "source": "oke-gpu-bus.json",
        "metricsReporting": true,
        "conditions": [
            {
            "type": "GpuBus",
            "reason": "GpuBusHasNoIssues",
            "message": "No GPU Bus issues detected with GPUs"
            }
        ],
        "rules": [
            {
            "type": "permanent",
            "condition": "GpuBus",
            "reason": "GpuBusHasIssues",
            "path": "./custom-config/oke_healthcheck.sh",
            "args": [ "gpu-bus" ],        
            "timeout": "30s"
            }
        ]
        }
    
    oke-gpu-count.json: |
        {
        "plugin": "custom",
        "pluginConfig": {
            "invoke_interval": "300s",
            "timeout": "30s",
            "max_output_length": 80,
            "concurrency": 1,
            "enable_message_change_based_condition_update": false
        },
        "source": "oke-gpu-count.json",
        "metricsReporting": true,
        "conditions": [
            {
            "type": "GpuCount",
            "reason": "GpuCountHasNoIssues",
            "message": "Node has the expected number of GPUs"
            }
        ],
        "rules": [
            {
            "type": "permanent",
            "condition": "GpuCount",
            "reason": "GpuCountHasIssues",
            "path": "./custom-config/oke_healthcheck.sh",
            "args": [ "gpu-count" ],        
            "timeout": "30s"
            }
        ]
        }    
    
    oke-gpu-pcie.json: |
        {
        "plugin": "custom",
        "pluginConfig": {
            "invoke_interval": "300s",
            "timeout": "30s",
            "max_output_length": 80,
            "concurrency": 1,
            "enable_message_change_based_condition_update": false
        },
        "source": "oke-gpu-pcie.json",
        "metricsReporting": true,
        "conditions": [
            {
            "type": "GpuPcie",
            "reason": "GpuPcieHasNoIssues",
            "message": "Node has the expected PCIE bandwidth"
            }
        ],
        "rules": [
            {
            "type": "permanent",
            "condition": "GpuPcie",
            "reason": "GpuPcieHasIssues",
            "path": "./custom-config/oke_healthcheck.sh",
            "args": [ "gpu-pcie" ],        
            "timeout": "30s"
            }
        ]
        }    

    oke-gpu-fabric-mgr.json: |
        {
        "plugin": "custom",
        "pluginConfig": {
            "invoke_interval": "300s",
            "timeout": "30s",
            "max_output_length": 80,
            "concurrency": 1,
            "enable_message_change_based_condition_update": false
        },
        "source": "oke-gpu-fabric-mgr.json",
        "metricsReporting": true,
        "conditions": [
            {
            "type": "GpuFabricMgr",
            "reason": "GpuFabricMgrHasNoIssues",
            "message": "Fabric Manager is running"
            }
        ],
        "rules": [
            {
            "type": "permanent",
            "condition": "GpuFabricMgr",
            "reason": "GpuFabricMgrHasIssues",
            "path": "./custom-config/oke_healthcheck.sh",
            "args": [ "gpu-fabric-mgr" ],        
            "timeout": "30s"
            }
        ]
        }

    oke-gpu-bad-pages.json: |
        {
        "plugin": "custom",
        "pluginConfig": {
            "invoke_interval": "300s",
            "timeout": "30s",
            "max_output_length": 80,
            "concurrency": 1,
            "enable_message_change_based_condition_update": false
        },
        "source": "oke-gpu-bad-pages.json",
        "metricsReporting": true,
        "conditions": [
            {
            "type": "GpuBadPages",
            "reason": "GpuBadPagesHasNoIssues",
            "message": "No GPU bad pages exists"
            }
        ],
        "rules": [
            {
            "type": "permanent",
            "condition": "GpuBadPages",
            "reason": "GpuBadPagesHasIssues",
            "path": "./custom-config/oke_healthcheck.sh",
            "args": [ "gpu-bad-pages" ],        
            "timeout": "30s"
            }
        ]
        }          

    oke-rdma-link.json: |
        {
        "plugin": "custom",
        "pluginConfig": {
            "invoke_interval": "300s",
            "timeout": "30s",
            "max_output_length": 80,
            "concurrency": 1,
            "enable_message_change_based_condition_update": false
        },
        "source": "oke-rdma-link.json",
        "metricsReporting": true,
        "conditions": [
            {
            "type": "RdmaLink",
            "reason": "RdmaLinkHasNoIssues",
            "message": "All RDMA links are up"
            }
        ],
        "rules": [
            {
            "type": "permanent",
            "condition": "RdmaLink",
            "reason": "RdmaLinkHasIssues",
            "path": "./custom-config/oke_healthcheck.sh",
            "args": [ "rdma-link" ],        
            "timeout": "30s"
            }
        ]
        }    

    oke-rdma-link-flapping.json: |
        {
        "plugin": "custom",
        "pluginConfig": {
            "invoke_interval": "300s",
            "timeout": "30s",
            "max_output_length": 80,
            "concurrency": 1,
            "enable_message_change_based_condition_update": false
        },
        "source": "oke-rdma-link-flapping.json",
        "metricsReporting": true,
        "conditions": [
            {
            "type": "RdmaLinkFlapping",
            "reason": "RdmaLinkFlappingHasNoIssues",
            "message": "No flapping RDMA links"
            }
        ],
        "rules": [
            {
            "type": "permanent",
            "condition": "RdmaLinkFlapping",
            "reason": "RdmaLinkFlappingHasIssues",
            "path": "./custom-config/oke_healthcheck.sh",
            "args": [ "rdma-link-flapping" ],        
            "timeout": "30s"
            }
        ]
        }   

    oke-rdma-wpa-auth.json: |
        {
        "plugin": "custom",
        "pluginConfig": {
            "invoke_interval": "300s",
            "timeout": "30s",
            "max_output_length": 80,
            "concurrency": 1,
            "enable_message_change_based_condition_update": false
        },
        "source": "oke-rdma-wpa-auth.json",
        "metricsReporting": true,
        "conditions": [
            {
            "type": "RdmaWpaAuth",
            "reason": "RdmaWpaAuthHasNoIssues",
            "message": "All RDMA links are authenticated"
            }
        ],
        "rules": [
            {
            "type": "permanent",
            "condition": "RdmaWpaAuth",
            "reason": "RdmaWpaAuthHasIssues",
            "path": "./custom-config/oke_healthcheck.sh",
            "args": [ "rdma-wpa-auth" ],        
            "timeout": "30s"
            }
        ]
        }   

    oke-rdma-rttcc.json: |
        {
        "plugin": "custom",
        "pluginConfig": {
            "invoke_interval": "300s",
            "timeout": "30s",
            "max_output_length": 80,
            "concurrency": 1,
            "enable_message_change_based_condition_update": false
        },
        "source": "oke-rdma-rttcc.json",
        "metricsReporting": true,
        "conditions": [
            {
            "type": "RdmaRttcc",
            "reason": "RdmaRttccHasNoIssues",
            "message": "RTCCC is disabled on all RDMA interfaces"
            }
        ],
        "rules": [
            {
            "type": "permanent",
            "condition": "RdmaRttcc",
            "reason": "RdmaRttccHasIssues",
            "path": "./custom-config/oke_healthcheck.sh",
            "args": [ "rdma-rttcc" ],        
            "timeout": "30s"
            }
        ]
        }   

    oke-oca-version.json: |
        {
        "plugin": "custom",
        "pluginConfig": {
            "invoke_interval": "300s",
            "timeout": "30s",
            "max_output_length": 80,
            "concurrency": 1,
            "enable_message_change_based_condition_update": false
        },
        "source": "oke-oca-version.json",
        "metricsReporting": true,
        "conditions": [
            {
            "type": "OcaVersion",
            "reason": "OcaVersionHasNoIssues",
            "message": "OCA version is up to date"
            }
        ],
        "rules": [
            {
            "type": "permanent",
            "condition": "OcaVersion",
            "reason": "OcaVersionHasIssues",
            "path": "./custom-config/oke_healthcheck.sh",
            "args": [ "oca-version" ],        
            "timeout": "30s"
            }
        ]
        }

    oke-cpu-profile.json: |
        {
        "plugin": "custom",
        "pluginConfig": {
            "invoke_interval": "300s",
            "timeout": "30s",
            "max_output_length": 80,
            "concurrency": 1,
            "enable_message_change_based_condition_update": false
        },
        "source": "oke-cpu-profile.json",
        "metricsReporting": true,
        "conditions": [
            {
            "type": "CpuProfile",
            "reason": "CpuProfileHasNoIssues",
            "message": "CPU profile is set to performance"
            }
        ],
        "rules": [
            {
            "type": "permanent",
            "condition": "CpuProfile",
            "reason": "CpuProfileHasIssues",
            "path": "./custom-config/oke_healthcheck.sh",
            "args": [ "cpu-profile" ],        
            "timeout": "30s"
            }
        ]
        }   

    oke_healthcheck.py: |
      #!/usr/bin/env python3
      
      import subprocess
      import re
      import argparse
      from datetime import datetime
      from shared_logging import logger
      # from gpu_bw_test import BandwidthTest
      from rdma_link_flapping import LinkFlappingTest
      from xid_checker import XidChecker
      import platform
      import os
      import requests
      import glob
      import json
      import time
      
      def get_metadata():
          # Make a request to metadata endpoint
          headers = { 'Authorization' : 'Bearer Oracle' }
          metadata_url = "http://169.254.169.254/opc/"
          metadata_ver = "2"
          request_url = metadata_url + "v" + metadata_ver + "/instance/"
          return requests.get(request_url, headers=headers).json()
      
      def is_user_root():
          # Check if the user is root
          if os.geteuid() != 0:
              logger.debug("User is not root!")
              return False
          return True
      
      def get_devices():
          # Define Mellanox devices based on GPU shape
          metadata = get_metadata()
          shape = metadata['shape']
      
          shape_devices = {
              "BM.GPU.H100.8": ["mlx5_0", "mlx5_1", "mlx5_3", "mlx5_4", "mlx5_5", "mlx5_6", "mlx5_7", "mlx5_8", "mlx5_9", "mlx5_10", "mlx5_12", "mlx5_13", "mlx5_14", "mlx5_15", "mlx5_16", "mlx5_17"],
              "BM.GPU.H200.8": ["mlx5_0", "mlx5_3", "mlx5_4", "mlx5_5", "mlx5_6", "mlx5_9", "mlx5_10", "mlx5_11"],
              "BM.GPU.B4.8": ["mlx5_1", "mlx5_2", "mlx5_3", "mlx5_4", "mlx5_5", "mlx5_6", "mlx5_7", "mlx5_8", "mlx5_9", "mlx5_10", "mlx5_11", "mlx5_12", "mlx5_14", "mlx5_15", "mlx5_16", "mlx5_17"],
              "BM.GPU.A100-v2.8": ["mlx5_1", "mlx5_2", "mlx5_3", "mlx5_4", "mlx5_5", "mlx5_6", "mlx5_7", "mlx5_8", "mlx5_9", "mlx5_10", "mlx5_11", "mlx5_12", "mlx5_14", "mlx5_15", "mlx5_16", "mlx5_17"],
              "BM.GPU4.8": ["mlx5_0", "mlx5_1", "mlx5_2", "mlx5_3", "mlx5_6", "mlx5_7", "mlx5_8", "mlx5_9", "mlx5_10", "mlx5_11", "mlx5_12", "mlx5_13", "mlx5_14", "mlx5_15", "mlx5_16", "mlx5_17"],
              "BM.GPU.MI300X.8": ["mlx5_0", "mlx5_1", "mlx5_2", "mlx5_3", "mlx5_6", "mlx5_7", "mlx5_8", "mlx5_9"]
          }
          if shape not in shape_devices:
              logger.info(f"RTTCC check not required for shape: {shape}")
              return []
          return shape_devices[shape]
      
      def get_oca_version():
          # Run the shell command
          os_name = platform.system()
      
          if os_name == 'Linux':
              try:
                  distro = platform.linux_distribution()[0]
              except:
                  import distro
                  distro = distro.name()
      
              if 'Ubuntu' in distro:
                  if not is_user_root():
                      result = subprocess.run(['sudo', 'snap', 'info', 'oracle-cloud-agent'], stdout=subprocess.PIPE)
                  else:
                      result = subprocess.run(['snap', 'info', 'oracle-cloud-agent'], stdout=subprocess.PIPE)
      
                  # Decode the output from bytes to string
                  output = result.stdout.decode('utf-8')
      
                  # Define the regular expression pattern for the version
                  pattern = r'installed:\s+(\d+\.\d+\.\d+)'
                  match = re.search(pattern, output)
                  if match:
                      version = match.group(1)
      
              elif 'Oracle' in distro:
                  result = subprocess.run(['rpm', '-qa'], stdout=subprocess.PIPE)
      
                  # Decode the output from bytes to string
                  output = result.stdout.decode('utf-8')
      
                  # Define the regular expression pattern for the version
                  pattern = r'oracle-cloud-agent-(\d+\.\d+\.\d+)'
                  match = re.search(pattern, output)
                  if match:
                      version = match.group(1)
      
              if version < "1.39.0":
                  logger.error(f"Oracle Cloud Agent: {version} needs to be updated to 1.39.0 or higher")
              else:
                  logger.info(f"Oracle Cloud Agent: {version}")
      
              # Return the version
              return version

      def check_oca_rdma_plugin_status():
          metadata=get_metadata()
          plugins_config = metadata.get('agentConfig', {}).get('pluginsConfig', [])
          enabled_plugins = {plugin['name']: plugin['desiredState'] for plugin in plugins_config}
      
          is_rdma_auto_configuration_enabled = enabled_plugins.get('Compute HPC RDMA Auto-Configuration') == 'ENABLED'
          is_rdma_authentication_enabled = enabled_plugins.get('Compute HPC RDMA Authentication') == 'ENABLED'
          
          if all([is_rdma_auto_configuration_enabled, is_rdma_authentication_enabled]):
              logger.info(f"OCA RDMA Plugins are enabled")
          else:
              logger.info(f"OCA RDMA Plugins are disabled")
          return all([is_rdma_auto_configuration_enabled, is_rdma_authentication_enabled])              
      
      def check_rttcc_status():
          # Check RTTCC status for supported GPU shapes and return status log.
          link_status = []
      
          devices = get_devices()
          status_dict = {"devices": {}}
          status = "disabled"
      
          for device in devices:
              command = [
                  "sudo" if not is_user_root() else "",
                  "mlxreg", "-d", device, "-y", "--get", "--reg_name=PPCC",
                  "--indexes=local_port=1,pnat=0,lp_msb=0,algo_slot=0,algo_param_index=0"
              ]
              command = [c for c in command if c]  # Remove empty elements
      
              try:
                  result = subprocess.run(command, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
                  output = result.stdout.decode('utf-8').split("\n")
      
                  for line in output:
                      if line.startswith("value"):
                          rttcc_value = line.split("|")[1].strip()
                          if rttcc_value == "0x00000001":
                              status_dict["devices"][device] = "enabled"
              except Exception as e:
                  logger.error(f"Failed to check RTTCC on {device}: {e}")
      
          for device in status_dict["devices"]:
              if status_dict["devices"][device] == "enabled":
                  logger.warning(f"RTTCC enabled on {device}")
                  status = "enabled"
                  link_status.append(f"RTTCC enabled on: {device}")
              else:
                  logger.info(f"RTTCC status for {device}: disabled")
          if status == "disabled":
              logger.info(f"RTTCC Disabled Check: Passed")
          else:
              logger.error(f"RTTCC Disabled Check: Failed")
      
          return link_status
      
      def check_ecc_errors():
          """Check ECC errors for NVIDIA or AMD GPUs."""
          ecc_issues = []
      
          try:
              result = subprocess.run(['nvidia-smi', '-q'], stdout=subprocess.PIPE)
              if result.returncode == 0:
                  output = result.stdout.decode('utf-8')
                  sram_matches = re.findall(r'SRAM Uncorrectable\s+:\s+(\d+)', output)
                  if len(sram_matches)==0:
                      sram_matches = re.findall(r'SRAM Uncorrectable Parity\s+:\s+(\d+)', output)
                  dram_matches = re.findall(r'DRAM Uncorrectable\s+:\s+(\d+)', output)
                  gpu_matches = re.findall(r'\nGPU\s+(.*)\n', output)
                  vol_sram_line = sram_matches[0::2]
                  vol_dram_line = dram_matches[0::2]
                  agg_sram_line = sram_matches[1::2]
                  agg_dram_line = dram_matches[1::2]
      
                  for i, gpu in enumerate(gpu_matches):
                      logger.debug(f"GPU: {gpu}")
                      if vol_sram_line[i] != "0":
                          logger.debug(f"Volatile SRAM Uncorrectable: {vol_sram_line[i]}")
                          ecc_issues.append(f"{gpu_matches[i]} - Volatile SRAM Uncorrectable: {vol_sram_line[i]}")
                      if vol_dram_line[i] != "0":
                          logger.debug(f"Volatile DRAM Uncorrectable: {vol_dram_line[i]}")
                          ecc_issues.append(f"{gpu_matches[i]} - Volatile DRAM Uncorrectable: {vol_dram_line[i]}")
                      if agg_sram_line[i] != "0":
                          logger.debug(f"Aggregate SRAM Uncorrectable: {agg_sram_line[i]}")
                          ecc_issues.append(f"{gpu_matches[i]} - Aggregate SRAM Uncorrectable: {agg_sram_line[i]}")
                      if agg_dram_line[i] != "0":
                          logger.debug(f"Aggregate DRAM Uncorrectable: {agg_dram_line[i]}")
                          ecc_issues.append(f"{gpu_matches[i]} - Aggregate DRAM Uncorrectable: {agg_dram_line[i]}")
      
          except (subprocess.CalledProcessError, FileNotFoundError):
              pass
      
              try:
                  THRESHOLD = 5
                  # Try detecting AMD GPU
                  result = subprocess.run(["amd-smi", "metric", "--ecc", "--json"], capture_output=True, check=True)
      
                  # Parse JSON output
                  gpu_data = json.loads(result.stdout.decode('utf-8'))
                  for gpu in gpu_data:
                      if gpu["ecc"]["total_uncorrectable_count"] > THRESHOLD:
                          ecc_issues.append(f"GPU {gpu['gpu']} - ECC Errors: {gpu['ecc']['total_uncorrectable_count']}")
      
              except (subprocess.CalledProcessError, FileNotFoundError):
                  logger.warning("Skipping SRAM/DRAM ECC Test: nvidia-smi | amd-smi command not found.")
                  return []
      
              except json.JSONDecodeError as e:
                  logger.error(f"Error decoding AMD JSON output: {e}")
                  return []
      
          if not ecc_issues:
              logger.info(f"GPU ECC Test: Passed")
          else:
              logger.warning(f"GPU ECC Test: Failed")
      
          return ecc_issues
      
      def check_row_remap_errors():
          remap_issues = []
          recommended_action=None
          if shape == "BM.GPU.MI300X.8":
              pass
          else:
              try:
                  # Run the nvidia-smi -q command
                  result = subprocess.run(['nvidia-smi', '--query-remapped-rows=remapped_rows.pending,remapped_rows.failure,remapped_rows.uncorrectable', '--format=csv,noheader'], stdout=subprocess.PIPE)
      
                  if result.returncode != 0:
                      logger.debug(f"Check row remap command exited with error code: {result.returncode}")
      
              except FileNotFoundError:
                  logger.warning("Skipping Row Remap Test: nvidia-smi command not found")
                  return []
              # Decode the output from bytes to string
              output = result.stdout.decode('utf-8')
              logger.debug("Output: {}".format(output))
              for i, line in enumerate(output.split('\n')):
                  if line == "":
                      continue
                  tmp_data = line.split(",")
                  tmp_data = [x.strip() for x in tmp_data]
                  if tmp_data[0] != "0" and tmp_data[0] != "No":
                      logger.debug(f"GPU: {i} - Row Remap Pending: {tmp_data[0]}")
                      remap_issues.append(f"GPU: {i} Row Remap Pending: {tmp_data[0]}")
                      recommended_action = "Reboot"
                  if tmp_data[1] != "0" and tmp_data[1] != "No":
                      logger.debug(f"GPU: {i} - Row Remap Failure: {tmp_data[1]}")
                      #remap_issues.append(f"GPU: {i} Row Remap Failure: {tmp_data[1]}")
                      recommended_action = "Terminate"
                  if tmp_data[2] != "0" and tmp_data[2] != "No":
                      logger.debug(f"GPU: {i} - Row Remap Uncorrectable: {tmp_data[2]}")
                      if int(tmp_data[2]) > 512:
                          remap_issues.append(f"GPU: {i} - Row Remap Uncorrectable >512: {tmp_data[2]}")
                          recommended_action = "Terminate"
                      else:
                          remap_issues.append(f"GPU: {i} - Row Remap Uncorrectable <512: {tmp_data[2]}")# Check if there are ecc_issues
                          recommended_action = "Reboot"
              if len(remap_issues) == 0:
                  logger.info("GPU Remap Test: Passed")
              else:
                  logger.warning("GPU Remap Test: Failed")
          return remap_issues, recommended_action
      
      def check_rdma_link_status():
          status = True
          
          link_issues = []
          devices = get_devices()
      
          for device in devices:
              # Run the mlxlink command
              if not is_user_root():
                  command = ['sudo', 'mlxlink', '-d', device, '-m', '-c', '-e']
              else:
                  command = ['mlxlink', '-d', device, '-m', '-c', '-e']
              result = subprocess.run(command, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
      
              # Decode the output from bytes to string
              output = result.stdout.decode('utf-8')
              stderr = result.stderr.decode('utf-8')
      
              if stderr and stderr.find("-E-") != -1:
                  stderr = stderr.split("\n")
                  stderr_line = ", ".join(stderr)
                  logger.debug(f"{device}: {stderr_line}")
                  link_issues.append(f"{device}: {stderr[0]}")
                  status = "False"
                  continue
      
              # Find the line containing "Recommendation"
              color_pattern = re.compile(r'\x1B(?:[@-Z\\-_]|\[[0-?]*[ -/]*[@-~])')
              link_state = re.search(r'\nState.*', output).group().split(":")[1].strip()
              recommendation = re.search(r'Recommendation.*', output).group().split(":")[1].strip()
              vendor_serial_num = re.search(r'Vendor Serial Number.*', output).group().split(":")[1].strip()
              nic_fw_version = re.search(r'Firmware Version.*', output).group().split(":")[1].strip()
              cable_fw_version = re.search(r'FW Version.*', output).group().split(":")[1].strip()
              physical_BER = re.search(r'Raw Physical BER.*', output).group().split(":")[1].strip()
              # Remove hidden characters from the output
              link_state = re.sub(color_pattern, '', link_state)
              nic_fw_version = re.sub(color_pattern, '', nic_fw_version)
              recommendation = re.sub(color_pattern, '', recommendation)
      
              logger.debug(f"{device}: {vendor_serial_num} - {cable_fw_version} - {nic_fw_version} - {link_state} - {recommendation}")
      
              # Extract the part after the ":" and print it along with the device name
              if link_state != "Active":
                  logger.debug(f"{device}: {link_state}")
                  link_issues.append(f"{device} - {vendor_serial_num} - {cable_fw_version} - {nic_fw_version}: {link_state}")
                  status = False
              if not "No issue was observed" in recommendation:
                  logger.debug(f"{device}: {recommendation}")
                  if "Bad signal integrity" in recommendation and float(physical_BER) < 1e-07:
                      logger.debug(f"Recommandation is {recommendation} but the Physical error are low enough that it can be ignored")
                  elif "Bad signal integrity" in recommendation and float(physical_BER) > 1e-07:
                      logger.debug(f"Recommandation is {recommendation} and the Physical error count is too high to be ignored: {physical_BER}")
                      link_issues.append(f"{device} - {vendor_serial_num} - {cable_fw_version} - {nic_fw_version}: {recommendation}")
                      status = False
                  else : 
                      logger.debug(f"Recommandation is {recommendation}")
                      link_issues.append(f"{device} - {vendor_serial_num} - {cable_fw_version} - {nic_fw_version}: {recommendation}")
                      status = False
              else:
                  logger.debug(f"{device}: {recommendation}")
      
          if status:
              logger.info(f"RDMA Link Status Check: Passed")
          else:
              logger.warning(f"RDMA Link Status Check: Failed")
          return link_issues
      
      def get_host_serial():
          # Run the shell command
          if not is_user_root():
              result = subprocess.run(['sudo', 'dmidecode', '-s', 'system-serial-number'], stdout=subprocess.PIPE)
          else:
              result = subprocess.run(['dmidecode', '-s', 'system-serial-number'], stdout=subprocess.PIPE)
      
          # Decode the output from bytes to string
          output = result.stdout.decode('utf-8')
      
          # Return the serial number
          return output.strip()
      
      def check_bus():
          # Check to see if any devices have fallen of the bus
          command = ['lspci', '-v']
          result = subprocess.run(command, stdout=subprocess.PIPE)
          output = result.stdout.decode('utf-8')
          lines = output.split('\n')
          bus_issues = []
          for line in lines:
              if line.find('(rev ff)') != -1:
                  bus_issues.append(line)
          if len(bus_issues) > 0:
              logger.error(f"Devices have fallen off the bus")
          if len(bus_issues) == 0:
              logger.info("Bus Check Test: Passed")
              return(bus_issues)
          else:
              logger.warning("Bus Check Test: Failed")
              return(bus_issues)
      
      def check_gpu_count():
      
          lspci_expected_results_gpu = [  '0f:00.0 3D controller: NVIDIA Corporation Device 2330 (rev a1)',
                                      '2d:00.0 3D controller: NVIDIA Corporation Device 2330 (rev a1)',
                                      '44:00.0 3D controller: NVIDIA Corporation Device 2330 (rev a1)',
                                      '5b:00.0 3D controller: NVIDIA Corporation Device 2330 (rev a1)',
                                      '89:00.0 3D controller: NVIDIA Corporation Device 2330 (rev a1)',
                                      'a8:00.0 3D controller: NVIDIA Corporation Device 2330 (rev a1)',
                                      'c0:00.0 3D controller: NVIDIA Corporation Device 2330 (rev a1)',
                                      'd8:00.0 3D controller: NVIDIA Corporation Device 2330 (rev a1)'
                                   ]
          lspci_expected_results_l40s = [  '16:00.0 3D controller: NVIDIA Corporation Device 26b9 (rev a1)',
                                           '38:00.0 3D controller: NVIDIA Corporation Device 26b9 (rev a1)',
                                           '82:00.0 3D controller: NVIDIA Corporation Device 26b9 (rev a1)',
                                           'ac:00.0 3D controller: NVIDIA Corporation Device 26b9 (rev a1)'
                                      ]
          lspci_expected_results_a10 = [  '17:00.0 3D controller: NVIDIA Corporation GA102GL [A10] (rev a1)',
                                          '31:00.0 3D controller: NVIDIA Corporation GA102GL [A10] (rev a1)',
                                          'b1:00.0 3D controller: NVIDIA Corporation GA102GL [A10] (rev a1)',
                                          'ca:00.0 3D controller: NVIDIA Corporation GA102GL [A10] (rev a1)'
                                      ]
          
          metadata=get_metadata()
          shape=metadata['shape']
          tmp_results = []
      
          # Check the number of GPUs for AMD
          if shape == "BM.GPU.MI300X.8":
              try:
                  result = subprocess.run(['amd-smi', 'list'], stdout=subprocess.PIPE)
                  output = result.stdout.decode('utf-8')
                  gpu_count = output.count("GPU")  # Count occurrences of "GPU"
                  tmp_results = []
                  expected_no_gpu = 8
      
                  if gpu_count == expected_no_gpu:
                      logger.info("GPU Count Test: Passed")
                  else:
                      logger.warning("GPU Count Test: Failed")
                      tmp_results.append(f"Expected {expected_no_gpu} GPUs, found {gpu_count} using amd-smi command")
      
              except FileNotFoundError:
                  logger.warning("Skipping GPU count test: amd-smi command not found")
      
              return tmp_results
      
          # Check the number of GPUs for NVIDIA
          try:
              result = subprocess.run(['nvidia-smi', '--list-gpus'], stdout=subprocess.PIPE)
              output = result.stdout.decode('utf-8')
              lines = output.split('\n')
              # remove empty lines
              lines = [line for line in lines if line]
              if shape == "BM.GPU.L40S-NC.4" or shape == "BM.GPU.A10.4":
                  if len(lines) == 4:
                      logger.info("GPU Count Test: Passed")
                  else:
                      logger.warning("GPU Count Test: Failed")
                      tmp_results.append(f"Expected 4 GPUs, found {len(lines)} using nvidia-smi command")
                  return tmp_results
              elif len(lines) == 8:
                  logger.info("GPU Count Test: Passed")
              else:
                  logger.warning("GPU Count Test: Failed")
                  tmp_results.append(f"Expected 8 GPUs, found {len(lines)} using nvidia-smi command")
              return tmp_results
      
          except FileNotFoundError:
              try:
                  # Check if lspci is available
                  result = subprocess.run(['lspci', '-v'], stdout=subprocess.PIPE)
                  output = result.stdout.decode('utf-8')
      
                  # Check if the expected results are in the output
                  lines = output.split('\n')
                  tmp_results = []
                  missing_gpus = []
                  metadata=get_metadata()
                  shape=metadata['shape']
                  find_number = ""
                  expected_gpus = ""
                  lspci_expected_results = ""
                  if shape == "BM.GPU.L40S-NC.4":
                      find_number = "26b9"
                      expected_gpus = 4
                      lspci_expected_results = lspci_expected_results_l40s
                  elif shape == "BM.GPU.A10.4":
                      find_number = "GA102GL"
                      expected_gpus = 4
                      lspci_expected_results = lspci_expected_results_a10
                  else:
                      find_number = "2330"
                      expected_gpus = 8
                      lspci_expected_results = lspci_expected_results_gpu
                  for line in lines:
                      if line.find("NVIDIA") != -1 and line.find(find_number) != -1:
                          tmp_results.append(line)
                  if not len(tmp_results) == expected_gpus:
                      logger.debug(f"Expected {expected_gpus} GPUs, found {len(tmp_results)} in lspci output")
                      for line in lspci_expected_results:
                          if line not in tmp_results:
                              missing_gpus.append(f"Missing GPU: {line}")
                  if len(tmp_results) == 8:
                      logger.info("GPU Count Test: Passed")
                  else:
                      logger.warning("GPU Count Test: Failed")
                  return missing_gpus
              except FileNotFoundError:
                  logger.warning("Skipping GPU count test: nvidia-smi and lspci commands not found")
                  return None
      
      def check_gpu_pcie():
          """Checks PCIe link width for NVIDIA or AMD based on instance shape."""
          # A100, H100, H200 and MI300X have x16
          metadata = get_metadata()
          shape = metadata.get('shape', '')
      
          expected_pcie_width = 16  # Expected PCIe width
      
          if shape == "BM.GPU.MI300X.8":
              try:
                  # Run amd-smi for AMD GPUs
                  result = subprocess.run(['amd-smi', 'metric', '--pcie'], stdout=subprocess.PIPE, check=True)
      
                  if result.returncode != 0:
                      logger.warning("GPU PCIe Width Test: Command amd-smi failed")
                      return None
                  else:
                      output = result.stdout.decode('utf-8')
      
                      # Extract PCIe WIDTH values correctly
                      pcie_widths = re.findall(r'^\s*WIDTH:\s*(\d+)', output, re.MULTILINE)
                      pcie_widths = list(map(int, pcie_widths)) if pcie_widths else []
      
                      if all(width == expected_pcie_width for width in pcie_widths):
                          logger.info("GPU PCIe Width Test: Passed")
                      else:
                          logger.warning("GPU PCIe Width Test: Failed")
                          return expected_pcie_width - int(sum(pcie_widths) / len(pcie_widths))
      
              except (FileNotFoundError, subprocess.CalledProcessError):
                  logger.warning("GPU PCIe Width Test: Skipping - amd-smi command not found")
                  return None
      
          else:
              try:
                  # Run nvidia-smi for NVIDIA GPUs
                  result = subprocess.run(
                      ['nvidia-smi', '--query-gpu=pcie.link.width.current', '--format=csv,noheader'],
                      stdout=subprocess.PIPE, check=True
                  )
      
                  if result.returncode != 0:
                      logger.warning("GPU PCIe Width Test: Command nvidia-smi failed")
                      return None
      
                  output = result.stdout.decode('utf-8').strip()
                  widths = list(map(int, output.split("\n")))
      
                  if all(width == expected_pcie_width for width in widths):
                      logger.info("GPU PCIe Width Test: Passed")
                  else:
                      logger.warning("GPU PCIe Width Test: Failed")
                      return expected_pcie_width - int(sum(widths) / len(widths))
      
              except (FileNotFoundError, subprocess.CalledProcessError):
                  logger.warning("GPU PCIe Width Test: Skipping - nvidia-smi command not found")
                  return None
      
          return None
      
      def check_wpa_auth(metadata):
          # Determine the shape and required authenticated count
          shape = metadata.get('shape')
          if shape in ["BM.GPU.H100.8", "BM.GPU.B4.8", "BM.GPU.A100-v2.8", "BM.GPU4.8"]:
              interface_range = range(16)
              required_authenticated = 16
          elif shape in ["BM.GPU.H200.8", "BM.GPU.MI300X.8"]:
              interface_range = range(8)
              required_authenticated = 8 
          else:
              logger.error("Unsupported machine shape.")
              return ["Unsupported machine shape."]
          
          authenticated_count = 0 
          wpa_auth_issues = []
          current_state = "None"  # Define initial state, can be updated based on actual logic
          interface_names=["rdma"+str(i) for i in interface_range]
          auth_status={key: 0 for key in interface_names}
          warning={key: [] for key in interface_names}
          for i in range(5):
          # Check each RDMA interface for WPA authentication status
              for interface in interface_names:
                  try:
                      if not is_user_root():
                          command = ['sudo', 'wpa_cli', 'status', '-i', interface]
                      else:
                          command = ['wpa_cli', 'status', '-i', interface]
      
                      result = subprocess.run(command, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
                      if result.stderr.decode('utf-8') != '':
                          warning[interface]=result.stderr.decode('utf-8').rstrip("\n")
                      for line in result.stdout.decode('utf-8').splitlines():
                          if "Supplicant PAE state" in line:
                              if "AUTHENTICATED" in line:
                                  auth_status[interface]=1
                              break
                  except subprocess.CalledProcessError as e:
                      wpa_auth_issues.append(f"Error checking {interface}: {e}")
                      logger.warning(f"Error checking {interface}: {e}")
              authenticated_count=sum(auth_status.values())
              if authenticated_count >= required_authenticated:
                  break
              else:
                  time.sleep(5)
              # Determine action based on authentication result
          if authenticated_count < required_authenticated:
              action = "Reboot"  # Set action as needed, e.g., "Reboot" if a reset is recommended
              wpa_auth_issues.append(f"Only {authenticated_count} interfaces are AUTHENTICATED; expected at least {required_authenticated}.")
              for i in warning.keys():
                  if auth_status[i]==0:
                      logger.warning(warning[i])
              logger.error("WPA Authentication Check: Failed")
          else:
              action = None  # No action if check passes
              logger.info("WPA Authentication Check: Passed")
      
          # Call the recommanded_action function
          final_action = recommended_action(current_state, action)
      
          return wpa_auth_issues if wpa_auth_issues else []
      
      def check_fabric_manager():
          fabric_manager_health = False
          try:
              # Run the nvidia-smi -q -i 0 | grep -i -A 2 Fabric
              result = subprocess.run('nvidia-smi -q -i 0 | grep -i -A 2 Fabric', shell=True, stdout=subprocess.PIPE)
              if result.returncode != 0:
                  logger.debug(f"Fabric Manager Check exited with error code: {result.returncode}")
      
          except FileNotFoundError:
              logger.warning("Skipping Fabric Manager test: nvidia-smi command not found")
              return fabric_manager_health
      
          # Decode the output from bytes to string
          output = result.stdout.decode('utf-8')
          logger.debug("Output: {}".format(output))
          fabric_manager_status=False
          fabric_manager_state=False
          for i, line in enumerate(output.split('\n')):
              if "State" in line:
                  if "Completed" in line:
                      fabric_manager_state = True
              elif "Status" in line:
                  if "Success" in line:
                      fabric_manager_status = True
              else:
                  continue
          fabric_manager_health= ( fabric_manager_status and fabric_manager_state )
          return fabric_manager_health
      
      def get_current_cpu_profile():
          """Retrieve online CPUs and check if their profile is set to 'performance'."""
          try:
              # Get online CPUs from lscpu
              output = subprocess.check_output(["lscpu"], universal_newlines=True)
              online_cpu_list = None
      
              for line in output.splitlines():
                  if "On-line CPU(s) list:" in line:
                      online_cpu_list = line.split(":")[1].strip()
                      break
      
              if not online_cpu_list:
                  logger.error("Could not determine online CPUs. Check `lscpu` output.")
                  return []
      
              # Convert CPU range to a list of integers
              online_cpus = []
              for part in online_cpu_list.split(","):
                  if "-" in part:
                      start, end = map(int, part.split("-"))
                      online_cpus.extend(range(start, end + 1))
                  else:
                      online_cpus.append(int(part))
      
          except Exception as e:
              logger.error(f"Failed to get online CPUs: {e}")
              return []
      
          # Check CPU governor for only online CPUs
          cpu_profile_issues = []
      
          for cpu_id in online_cpus:
              cpu_file = f"/sys/devices/system/cpu/cpu{cpu_id}/cpufreq/scaling_governor"
              for attempt in range(3):  # Retry up to 3 times
                  try:
                      with open(cpu_file, 'r') as f:
                          result = f.read().strip()
      
                      if result == "performance":
                          continue
                      else:
                          logger.warning(f"CPU {cpu_id}: Profile is '{result}', expected 'performance'.")
                          cpu_profile_issues.append(f"CPU {cpu_id}: {result}")
      
                      break  # Exit retry loop on success
      
                  except Exception as e:
                      if "Device or resource busy" in str(e):
                          if attempt < 2:
                              time.sleep(0.5)  # Wait before retrying
                          else:
                              logger.warning(f"CPU {cpu_id}: Scaling governor file is busy. Skipping after 3 attempts.")
                      else:
                          logger.error(f"Skipping CPU {cpu_id}: {e}")
                          break  # Skip CPU if persistently busy
      
          if not cpu_profile_issues:
              logger.info("CPU Profile Check: Passed") #All CPUs are set to 'performance'.
          else:
              logger.error("Some CPUs failed the profile check.")
      
          return cpu_profile_issues
      
      def check_bad_pages():
          try:
              result = subprocess.run(["amd-smi", "bad-pages", "--json"], capture_output=True, check=True)
              data = json.loads(result.stdout.decode('utf-8'))
          except (subprocess.CalledProcessError, json.JSONDecodeError) as e:
              print(f"Error executing amd-smi or parsing JSON: {e}")
              return
      
          errors = []
      
          for gpu in data:
              if gpu.get("pending") != "No bad pages found.":
                  errors.append(f"Error: GPU {gpu['gpu']} has bad pages pending: {gpu['pending']}")
      
          if errors:
              for error in errors:
                  print(error)
          else:
              logger.info("GPU Pending Bad Pages Check: Passed")
      
      def slurm_reason(message):
          global slurm_drain_reason
          global slurm_error_count
          slurm_drain_reason+=(message+"\n")
          slurm_error_count+=1
      
      def recommended_action(current, action):
          if action not in [None,"FabricManagerRestart","Reboot","LiveFix","Reboot&LiveFix","Terminate"]:
              print("No action was found")
              return 0
          if action == "Reboot" or action == "FabricManagerRestart":
              if current == "Terminate":
                  return current
              elif current == "LiveFix":
                  return "Reboot&LiveFix"
              elif current == "Reboot&LiveFix":
                  return "Reboot&LiveFix"
              else:
                  return action
          if action == "LiveFix":
              if current == "Terminate":
                  return current
              elif current == "Reboot":
                  return "Reboot&LiveFix"
              elif current == "Reboot&LiveFix":
                  return "Reboot&LiveFix"
              elif current == "FabricManagerRestart":
                  return "Reboot&LiveFix"
              else:
                  return action
          if action is None: 
              return current
          if action == "Terminate":
              return action
      
      if __name__ == '__main__':
          action = None
          parser = argparse.ArgumentParser(description='Check Host setup')
          parser.add_argument("-l", "--log-level", choices=["DEBUG", "INFO", "WARNING", "ERROR", "CRITICAL"], default="INFO", help="Set the logging level default: INFO")
          parser.add_argument('--bw-test', action='store_true', help='Run GPU bandwidth test')
          parser.add_argument('--bw-test-exe', help='Location to cuda-samples bandwidthTest')
          parser.add_argument('--lf-interval', type=int, default=6, help='Link flapping interval with no flapping or link down events (default: 6 hours)')
          parser.add_argument('-slurm', '--slurm', '--short', action='store_true', help='Add a Slurm message')
          parser.add_argument('--ocaver', '--oca-version', action='store_true', help='Run OCA version check')
          parser.add_argument('--rttcc', '--rdma-rttcc', action='store_true', help='Run RTTCC status check')
          parser.add_argument('--eccerr', '--gpu-ecc', action='store_true', help='Run ECC errors check')
          parser.add_argument('--rowerr', '--gpu-row-remap', action='store_true', help='Run row remap errors check')
          parser.add_argument('--rdmalink', '--rdma-link', action='store_true', help='Run RDMA link status check')
          parser.add_argument('--busstat', '--gpu-bus', action='store_true', help='Run bus status check')
          parser.add_argument('--gpucount', '--gpu-count', action='store_true', help='Run GPU count check')
          parser.add_argument('--gpupcie', '--gpu-pcie', action='store_true', help='Run GPU PCIe check')
          parser.add_argument('--wpa-auth', '--rdma-wpa-auth', action='store_true', help='Run WPA authentication check')
          parser.add_argument('--fabric-mgr', '--gpu-fabric-mgr', action='store_true', help='Run Fabric Manager check')
          parser.add_argument('--cpu-profile', action='store_true', help='Run CPU profile check')
          parser.add_argument('--bad-page', '--gpu-bad-pages', action='store_true', help='Run bad pages check')
          parser.add_argument('-oca-rdma-plugin-status', '--oca-rdma-plugin-status', dest='oca_rdma_plugin_status',action="store_true", default=False, help="Check if the RDMA plugins are enabled")
          args = parser.parse_args()
      
          metadata = get_metadata()
          shape = metadata['shape']
      
          logger.setLevel(args.log_level)
      
          datetime_str = datetime.now().strftime('%Y-%m-%d-%H%M%S')
          logger.info(f"Started GPU host setup check at: {datetime_str}")
      
          metadata = get_metadata()
          shape = metadata['shape']
      
          # Run everything if no arguments are provided
          run_all = not any(getattr(args, arg) for arg in vars(args) if isinstance(getattr(args, arg), bool))
      
          if run_all or args.ocaver:
              # Check for OCA Version
              try:
                  oca_version = get_oca_version()
              except Exception as e:
                  logger.warning(f"Failed to get Oracle Cloud Agent version with error: {e}")
                  oca_version = "Unknown"
      
          if run_all or args.rttcc:
              # Check for RTTCC Issues
              if shape != "BM.GPU.H200.8":
                  try:
                      rttcc_issues = check_rttcc_status()
                  except Exception as e:
                      logger.warning(f"Failed to check RTTCC status with error: {e}")
                      rttcc_issues = []
              else:
                  rttcc_issues = []
      
          if run_all or args.eccerr:
              # Check for ECC errors
              try:
                  ecc_issues = check_ecc_errors()
              except Exception as e:
                  logger.warning(f"Failed to check ECC errors with error: {e}")
                  ecc_issues = []
      
          if run_all or args.rowerr:
              # Check for row remap errors
              try:
                  remap_results, row_remap_action = check_row_remap_errors()
              except Exception as e:
                  logger.warning(f"Failed to check row remap errors with error: {e}")
                  remap_results = []
      
          if run_all or args.rdmalink:
              # Check for RDMA link status
              try:
                  rdma_link_issues = check_rdma_link_status()
              except Exception as e:
                  logger.warning(f"Failed to check RDMA link status with error: {e}")
                  rdma_link_issues = []
      
          if run_all or args.busstat:
              # Check the bus
              try:
                  bus_results = check_bus()
              except Exception as e:
                  logger.warning(f"Failed to check the bus with error: {e}")
                  bus_results = None
      
          if run_all or args.gpucount:
              # Check the number of GPUs
              try:
                  gpu_results = check_gpu_count()
              except Exception as e:
                  logger.warning(f"Failed to check the number of GPUs with error: {e}")
                  gpu_results = None
      
          if run_all or args.gpupcie:
              # Check GPU PCIe Widths
              try:
                  gpu_pcie_results = check_gpu_pcie()
              except Exception as e:
                  logger.warning(f"Failed to check GPU PCIe Width with error: {e}")
                  gpu_pcie_results = None
      
          if run_all or args.wpa_auth:
              # Check WPA authentication if the option is set
              try:
                  wpa_auth_results = check_wpa_auth(metadata)
              except Exception as e:
                  logger.warning(f"Failed to get WPA Authentication status: {e}")
                  wpa_auth_results = None
      
          if run_all or args.fabric_mgr:
              # Check for Fabric Manager Started
              if shape == "BM.GPU.H100.8" or shape == "BM.GPU.H200.8":
                  try:
                      fabric_manager_health = check_fabric_manager()
                  except Exception as e:
                      logger.warning(f"Failed to check Fabric Manager with error: {e}")
                      fabric_manager_health = True
      
                  if fabric_manager_health:
                      logger.info("Fabric Manager Running: Passed")
              else:
                  fabric_manager_health = True
      
          if run_all or args.cpu_profile:
              # Check CPU Profile is performance
              try:
                  cpu_profile_issues = get_current_cpu_profile()
              except Exception as e:
                  logger.warning(f"Failed to check CPU profile with error: {e}")
                  cpu_profile_issues = []
      
          if run_all or args.bad_page:
              # Check if AMD GPU has pending bad pages
              try:
                  if shape == "BM.GPU.MI300X.8":
                      bad_page_issues = check_bad_pages()
                  else:
                      bad_page_issues = None
              except Exception as e:
                  logger.warning(f"Failed to check pending bad pages: {e}")
                  bad_page_issues = []
          
          if args.oca_rdma_plugin_status:
              # Check for OCA RDMA Plugin status
              try:
                   oca_rdma_plugin_status = check_oca_rdma_plugin_status()
              except Exception as e:
                  logger.warning(f"Failed to check OCA RDMA Plugins Status with error: {e}")
                  oca_rdma_plugin_status = []                  
      
          # Summarize the results
          try:
              host_serial = get_host_serial()
          except Exception as e:
              logger.warning(f"Failed to get host serial number with error: {e}")
              host_serial = "Unknown"
      
          slurm_drain_reason = ""
          slurm_error_count = 0
      
          logger.info(f"--------- Summary of Host setup check for {host_serial} ---------")
      
          if run_all or args.ocaver:
              if oca_version < "1.39.0":
                  logger.error(f"Oracle Cloud Agent: {oca_version} needs to be updated to 1.39.0 or higher")
                  slurm_reason("OCA version Error")
      
          if run_all or args.rttcc:
              if shape != "BM.GPU.MI300X.8":
                  if len(rttcc_issues) > 0:
                      logger.error(f"RTTCC issues: {rttcc_issues}")
                      slurm_reason("RTTCC Error")
      
          if run_all or args.eccerr:
              if len(ecc_issues) > 0:
                  ecc_error = False
                  for issue in ecc_issues:
                      if "Skipped" in issue:
                          logger.warning(f"{host_serial} - {issue}")
                      else:
                          if "Aggregate" in issue:
                              logger.warning(f"{host_serial} - ECC issues: {issue}")
                          else:
                              logger.error(f"{host_serial} - ECC issues: {issue}")
                              ecc_error = True
                  if ecc_error:
                      slurm_reason("ECC Error")
                      action = recommended_action(action, "Reboot")
      
          if run_all or args.rowerr:
              if len(remap_results) > 0:
                  remap_error = False
                  for issue in remap_results:
                      if "<512" in issue:
                          logger.warning(f"{host_serial} - {issue}")
                      else:
                          logger.error(f"{host_serial} - {issue}")
                          remap_error = True
                  if remap_error:
                      slurm_reason("Remap Error")
                      action = recommended_action(action, row_remap_action)
      
          if run_all or args.rdmalink:
              if len(rdma_link_issues) > 0:
                  for issue in rdma_link_issues:
                      logger.error(f"{host_serial} - RDMA link issues: {issue}")
                      slurm_reason("RDMA Link Error")
                      if "signal not detected" in issue:
                          logger.info("No signal detected doesn't always come from a bad cable and require a termination for investigation")
                          action = recommended_action(action, "Terminate")
                      else:
                          action = recommended_action(action, "LiveFix")
      
          if run_all or args.busstat:
              if bus_results:
                  logger.error(f"{host_serial} - Bus issues: {bus_results}")
                  slurm_reason("GPU Bus Error")
                  action = recommended_action(action, "Terminate")
      
          if run_all or args.gpucount:
              if gpu_results:
                  logger.error(f"{host_serial} - Missing GPU(s): {gpu_results}")
                  slurm_reason("Missing GPU Error")
                  action = recommended_action(action, "Reboot")
      
          if run_all or args.gpupcie:
              if gpu_pcie_results:
                  logger.error(f"{host_serial} - GPU PCIe Width: {gpu_pcie_results}")
                  slurm_reason("GPU PCIe Width Error")
                  action = recommended_action(action, "Terminate")
      
          if run_all or args.wpa_auth:
              if wpa_auth_results:
                  for issue in wpa_auth_results:
                      logger.error(f"{host_serial} - WPA authentication issue: {issue}")
                  slurm_reason("WPA Auth Error")
                  action = recommended_action(action, "Reboot")
      
          if run_all or args.fabric_mgr:
              if not fabric_manager_health:
                  logger.error(f"{host_serial} - Fabric Manager not started")
                  slurm_reason("Fabric Manager Error")
                  action = recommended_action(action, "FabricManagerRestart")
      
          if run_all or args.cpu_profile:
              if cpu_profile_issues:
                  logger.error(f"CPU Profile need to be 'performance'.")
                  for issue in cpu_profile_issues:
                      logger.error(f" - {issue}")
                  slurm_reason("CPU Profile error")
                  action = recommended_action(action, "Reboot&LiveFix")
      
          if run_all or args.bad_page:
              if bad_page_issues:
                  for issue in bad_page_issues:
                      logger.error(f"{host_serial} - GPU has pending bad pages: {issue}")
                  slurm_reason("GPU Bad page error")
                  action = recommended_action(action, "Reboot")
      
          logger.info(f"Finished GPU host setup check at: {datetime_str}")
          if action == "Reboot":
              logger.error("Recommended Action is to Force Reboot from the console or API")
          if action == "LiveFix":
              logger.error("Recommended Action is to Create a SR to Get the node fixed live")
          if action == "Reboot&LiveFix":
              logger.error("Recommended Action is to Create a SR to Get the node fixed live as well as force reboot the node")
          if action == "Terminate":
              logger.error("Recommended Action is to Terminate the node and Create a SR")
      
          if slurm_error_count > 0 and args.slurm:
              print("Healthcheck:: " + slurm_drain_reason[:-1])
              print("Healthcheck:: Recommended Action:" + str(action))    

    rdma_link_flapping.py: |
            #!/usr/bin/env python3

            import os
            import sys
            import time
            import datetime
            import re
            import argparse
            import socket
            import subprocess
            from shared_logging import logger


            class LinkFlappingTest:
                def __init__(self, time_interval=6):
                    self.results = None
                    self.time_interval = int(time_interval)
                    self.link_data = None

                    # Check if the log file exists
                    msg_file = "/var/log/messages"
                    if not os.path.exists(msg_file):
                        msg_file = "/var/log/syslog"
                    self.log_file = msg_file

                def get_rdma_link_failures(self):

                    pattern  = r"(\w{3}\s+\d{1,2}\s+\d{2}:\d{2}:\d{2})\s+\S+\s+wpa_supplicant(?:\[\d+\])?: (\w+): CTRL-EVENT-EAP-FAILURE EAP authentication failed"
                    pattern2 = r"(\w{3}\s+\d{1,2}\s+\d{2}:\d{2}:\d{2})\s+\S+\s+kernel: (?:\[\d+\.\d+\]\s)?mlx5_core \S+ (\w+): Link down"
                    
                    self.link_data = {}
                    with open(self.log_file, "r") as f:
                        for line in f:
                            match = re.search(pattern, line)
                            if match:
                                time_str = match.group(1)
                                interface = match.group(2)
                                logger.debug(f"time: {time_str}, interface: {interface}")
                                if interface not in self.link_data:
                                    self.link_data[interface] = {"failures": [time_str], "link_down": []}
                                else:
                                    self.link_data[interface]["failures"].append(time_str)

                            
                            match = re.search(pattern2, line)
                            if match:
                                time_str = match.group(1)
                                interface = match.group(2)
                                logger.debug(f"time: {time_str}, interface: {interface}")
                                if interface not in self.link_data:
                                    self.link_data[interface] = {"failures": [], "link_down": [time_str]}
                                else:
                                    self.link_data[interface]["link_down"].append(time_str)
                                    
                    logger.debug("Link Data: {}".format(self.link_data))
                    return self.link_data

                def process_rdma_link_flapping(self):

                    link_issues = {"failures": [], "link_down": []}

                    # Get the time stamp when the host came up
                    bootup_time = subprocess.run(['uptime', '-s'], stdout=subprocess.PIPE)
                    bootup_time = bootup_time.stdout.decode('utf-8').strip()
                    bootup_time_str = datetime.datetime.strptime(bootup_time, "%Y-%m-%d %H:%M:%S")
                    bootup_time_sec = int(time.mktime(bootup_time_str.timetuple()))
                    bootup_time_grace_period = bootup_time_sec + 1800

                    status = 0
                    if len(self.link_data) >= 0:
                        current_date = datetime.datetime.now()
                        current_date_str = current_date.strftime("%Y-%b-%d %H:%M:%S")
                        current_date_sec = int(time.mktime(datetime.datetime.strptime(current_date_str, "%Y-%b-%d %H:%M:%S").timetuple()))
                        
                        link_failures = False
                        for interface in self.link_data:
                            if len(self.link_data[interface]["failures"]) > 0:
                                link_failures = True
                                logger.debug(f"{interface}: {len(self.link_data[interface]['failures'])} RDMA link failure entries in {self.log_file}")
                                logger.debug(f"{interface}: {self.link_data[interface]['failures']}")        
                            last_date_failure_str = None

                            if len(self.link_data[interface]["failures"]) > 0:
                                last_date_failure_str = self.link_data[interface]["failures"][-1]
                                last_date_failure = datetime.datetime.strptime(last_date_failure_str, "%b %d %H:%M:%S")

                                # Compare the month of the last failure date with the current month
                                if last_date_failure.month > current_date.month:
                                    # If the last failure month is greater than the current month, subtract one from the current year
                                    last_date_failure = last_date_failure.replace(year=current_date.year - 1)
                                else:
                                    # Otherwise, set the year of the last failure date to the current year
                                    last_date_failure = last_date_failure.replace(year=current_date.year)

                                # Convert the last failure date to seconds since the epoch
                                last_date_failure_sec = int(time.mktime(last_date_failure.timetuple()))
                            
                            if last_date_failure_str != None and last_date_failure_str != current_date_str:
                                diff_secs = current_date_sec - last_date_failure_sec
                                diff_hours = diff_secs // (60 * 60)
                                logger.debug(f"RDMA link ({interface}) failed  {diff_hours} hours ago")

                                logger.debug(f"bootup_time_sec: {bootup_time_sec}, boot_time_grace_period: {bootup_time_grace_period}, current_date_sec: {current_date_sec}, diff_secs: {diff_secs}, diff_hours: {diff_hours}")
                                if diff_hours < self.time_interval and last_date_failure_sec > bootup_time_grace_period:
                                    logger.debug(f"{interface}: one or more RDMA link flapping events within {self.time_interval} hours. Last flapping event: {last_date_failure_str})")
                                    link_issues["failures"].append(f"{interface}: {len(self.link_data[interface]['failures'])}")
                                    status = -1

                        for interface in self.link_data:
                            if len(self.link_data[interface]["link_down"]) > 0:
                                logger.debug(f"{interface}: {len(self.link_data[interface]['link_down'])} RDMA link down entries in {self.log_file}")
                                logger.debug(f"{interface}: {self.link_data[interface]['link_down']}")
                            last_date_down_str = None

                            if len(self.link_data[interface]["link_down"]) > 0:
                                    last_date_down_str = self.link_data[interface]["link_down"][-1]
                                    last_date_down = datetime.datetime.strptime(last_date_down_str, "%b %d %H:%M:%S")

                                    # Compare the month of the last failure date with the current month
                                    if last_date_down.month > current_date.month:
                                        # If the last failure month is greater than the current month, subtract one from the current year
                                        last_date_down = last_date_down.replace(year=current_date.year - 1)
                                    else:
                                        # Otherwise, set the year of the last failure date to the current year
                                        last_date_down = last_date_down.replace(year=current_date.year)

                                    # Convert the last failure date to seconds since the epoch
                                    last_date_down_sec = int(time.mktime(last_date_down.timetuple()))


                            if last_date_down_str != None and last_date_down_str != current_date_str:
                                diff_secs = current_date_sec - last_date_down_sec
                                diff_hours = diff_secs // (60 * 60)
                                logger.debug(f"RDMA link ({interface}) down  {diff_hours} hours ago")
                                
                                logger.debug(f"bootup_time_sec: {bootup_time_sec}, boot_time_grace_period: {bootup_time_grace_period}, current_date_sec: {current_date_sec}, diff_secs: {diff_secs}, diff_hours: {diff_hours}")
                                if diff_hours < self.time_interval and last_date_down_sec > bootup_time_grace_period:
                                    logger.debug(f"{interface}, one or more RDMA link down events within {self.time_interval} hours. Last link down event: {last_date_down_str}")
                                    link_issues["link_down"].append(f"{interface}: {len(self.link_data[interface]['link_down'])}")
                                    status = -2
                        if status == -1:
                            logger.debug(f"One or more RDMA link flapping events within the past {self.time_interval} hours")
                        if status == -2:
                            logger.debug(f"One or more RDMA link down events within the past {self.time_interval} hours")

                    else:
                        logger.info("No RDMA link failures entry in /var/log/messages")
                    if status == 0:    
                        logger.info("RDMA link flapping/down test: Passed")
                    else:
                        logger.warning("RDMA link flapping/down test: Failed")
                    return link_issues


            if __name__ == "__main__":

                parser = argparse.ArgumentParser(description="Process RDMA link flapping data")
                parser.add_argument("-l", "--log-level", choices=["DEBUG", "INFO", "WARNING", "ERROR", "CRITICAL"], default="INFO", help="Set the logging level")
                args = parser.parse_args()

                logger.setLevel(args.log_level)

                auth_failure_file = "/tmp/last_auth_failure_date"
                msg_file = "/var/log/messages"
                if not os.path.exists(msg_file):
                    msg_file = "/var/log/syslog"
                time_interval_hours = 6
                lft = LinkFlappingTest(time_interval=time_interval_hours)
                link_data = lft.get_rdma_link_failures()
                lft.process_rdma_link_flapping()
    xid_checker.py: |
        #!/usr/bin/env python3

        import argparse
        from shared_logging import logger
        import subprocess
        import sys
        import re
        import os

        class XidChecker:
            def __init__(self, dmesg_cmd="dmesg", time_interval=60):
                # if user is root
                if not os.geteuid() == 0:
                    logger.info("The XidChecker script did not run since it must be run as root")
                    sys.exit(1)
                self.dmesg_cmd = dmesg_cmd
                self.results = {}


                # Check for the following GPU Xid errors in dmesg
                self.XID_EC = {
                        "1": {"description": "Invalid or corrupted push buffer stream", "severity": "Critical"},
                        "2": {"description": "Invalid or corrupted push buffer stream", "severity": "Critical"},
                        "3": {"description": "Invalid or corrupted push buffer stream", "severity": "Critical"},
                        "4": {"description": "Invalid or corrupted push buffer stream", "severity": "Critical"},
                        "5": {"description": "Unused", "severity": "Critical"},
                        "6": {"description": "Invalid or corrupted push buffer stream", "severity": "Critical"},
                        "7": {"description": "Invalid or corrupted push buffer address", "severity": "Critical"},
                        "8": {"description": "GPU stopped processing", "severity": "Critical"},
                        "9": {"description": "Driver error programming GPU", "severity": "Critical"},
                        "10": {"description": "Unused", "severity": "Critical"},
                        "11": {"description": "Invalid or corrupted push buffer stream", "severity": "Critical"},
                        "12": {"description": "Driver error handling GPU exception", "severity": "Critical"},
                        "13": {"description": "Graphics Engine Exception", "severity": "Critical"},
                        "14": {"description": "Unused", "severity": "Warn"},
                        "15": {"description": "Unused", "severity": "Warn"},
                        "16": {"description": "Display engine hung", "severity": "Warn"},
                        "17": {"description": "Unused", "severity": "Warn"},
                        "18": {"description": "Bus mastering disabled in PCI Config Space", "severity": "Warn"},
                        "19": {"description": "Display Engine error", "severity": "Warn"},
                        "20": {"description": "Invalid or corrupted Mpeg push buffer", "severity": "Warn"},
                        "21": {"description": "Invalid or corrupted Motion Estimation push buffer", "severity": "Warn"},
                        "22": {"description": "Invalid or corrupted Video Processor push buffer", "severity": "Warn"},
                        "23": {"description": "Unused", "severity": "Warn"},
                        "24": {"description": "GPU semaphore timeout", "severity": "Warn"},
                        "25": {"description": "Invalid or illegal push buffer stream", "severity": "Warn"},
                        "26": {"description": "Framebuffer timeout", "severity": "Warn"},
                        "27": {"description": "Video processor exception", "severity": "Warn"},
                        "28": {"description": "Video processor exception", "severity": "Warn"},
                        "29": {"description": "Video processor exception", "severity": "Warn"},
                        "30": {"description": "GPU semaphore access error", "severity": "Warn"},
                        "31": {"description": "GPU memory page fault", "severity": "Critical"},    
                        "32": {"description": "Invalid or corrupted push buffer stream", "severity": "Warn"},
                        "33": {"description": "Internal micro-controller error", "severity": "Warn"},
                        "34": {"description": "Video processor exception", "severity": "Warn"},
                        "35": {"description": "Video processor exception", "severity": "Warn"},
                        "36": {"description": "Video processor exception", "severity": "Warn"},
                        "37": {"description": "Driver firmware error", "severity": "Warn"},
                        "38": {"description": "Driver firmware error", "severity": "Warn"},
                        "39": {"description": "Unused", "severity": "Warn"},
                        "40": {"description": "Unused", "severity": "Warn"},
                        "41": {"description": "Unused", "severity": "Warn"},
                        "42": {"description": "Video processor exception", "severity": "Warn"},
                        "43": {"description": "GPU stopped processing", "severity": "Warn"},
                        "44": {"description": "Graphics Engine fault during context switch", "severity": "Warn"},
                        "45": {"description": "Preemptive cleanup, due to previous errors -- Most likely to see when running multiple cuda applications and hitting a DBE", "severity": "Warn"},
                        "46": {"description": "GPU stopped processing", "severity": "Warn"},
                        "47": {"description": "Video processor exception", "severity": "Warn"},
                        "48": {"description": "Double Bit ECC Error", "severity": "Critical"}, 
                        "49": {"description": "Unused", "severity": "Warn"},
                        "50": {"description": "Unused", "severity": "Warn"},
                        "51": {"description": "Unused", "severity": "Warn"},
                        "52": {"description": "Unused", "severity": "Warn"},
                        "53": {"description": "Unused", "severity": "Warn"},
                        "54": {"description": "Auxiliary power is not connected to the GPU board", "severity": "Warn"},
                        "55": {"description": "Unused", "severity": "Warn"},
                        "56": {"description": "Display Engine error", "severity": "Critical"},
                        "57": {"description": "Error programming video memory interface", "severity": "Critical"},
                        "58": {"description": "Unstable video memory interface detected", "severity": "Critical"},
                        "59": {"description": "Internal micro-controller error (older drivers)", "severity": "Warn"},
                        "60": {"description": "Video processor exception", "severity": "Warn"},
                        "61": {"description": "Internal micro-controller breakpoint/warning (newer drivers)", "severity": "Warn"},
                        "62": {"description": "Internal micro-controller halt", "severity": "Critical"},
                        "63": {"description": "ECC page retirement or row remapping recording event", "severity": "Critical"},
                        "64": {"description": "ECC page retirement or row remapper recording failure", "severity": "Critical"},
                        "65": {"description": "Video processor exception", "severity": "Critical"},
                        "66": {"description": "Illegal access by driver", "severity": "Warn"},
                        "67": {"description": "Illegal access by driver", "severity": "Warn"},
                        "68": {"description": "NVDEC0 Exception", "severity": "Critical"},
                        "69": {"description": "Graphics Engine class error", "severity": "Critical"},
                        "70": {"description": "CE3: Unknown Error", "severity": "Warn"},
                        "71": {"description": "CE4: Unknown Error", "severity": "Warn"},
                        "72": {"description": "CE5: Unknown Error", "severity": "Warn"},
                        "73": {"description": "NVENC2 Error", "severity": "Critical"},
                        "74": {"description": "NVLINK Error", "severity": "Critical"},
                        "75": {"description": "CE6: Unknown Error", "severity": "Warn"},
                        "76": {"description": "CE7: Unknown Error", "severity": "Warn"},
                        "77": {"description": "CE8: Unknown Error", "severity": "Warn"},
                        "78": {"description": "vGPU Start Error", "severity": "Warn"},
                        "79": {"description": "GPU has fallen off the bus", "severity": "Critical"},
                        "80": {"description": "Corrupted data sent to GPU", "severity": "Critical"},
                        "81": {"description": "VGA Subsystem Error", "severity": "Critical"},
                        "82": {"description": "NVJPGO Error", "severity": "Warn"},
                        "83": {"description": "NVDEC1 Error", "severity": "Warn"},
                        "84": {"description": "NVDEC2 Error", "severity": "Warn"},
                        "85": {"description": "CE9: Unknown Error", "severity": "Warn"},
                        "86": {"description": "OFA Exception", "severity": "Warn"},
                        "87": {"description": "Reserved", "severity": "Warn"},
                        "88": {"description": "NVDEC3 Error", "severity": "Warn"},
                        "89": {"description": "NVDEC4 Error", "severity": "Warn"},
                        "90": {"description": "Reserved", "severity": "Warn"},
                        "91": {"description": "Reserved", "severity": "Warn"},
                        "92": {"description": "High single-bit ECC error rate", "severity": "Critical"},
                        "93": {"description": "Non-fatal violation of provisioned InfoROM wear limit", "severity": "Warn"},
                        "94": {"description": "Contained ECC error", "severity": "Critical"},
                        "95": {"description": "Uncontained ECC error", "severity": "Critical"},
                        "96": {"description": "NVDEC5 Error", "severity": "Warn"},
                        "97": {"description": "NVDEC6 Error", "severity": "Warn"},
                        "98": {"description": "NVDEC7 Error", "severity": "Warn"},
                        "99": {"description": "NVJPG1 Error", "severity": "Warn"},
                        "100": {"description": "NVJPG2 Error", "severity": "Warn"},
                        "101": {"description": "NVJPG3 Error", "severity": "Warn"},
                        "102": {"description": "NVJPG4 Error", "severity": "Warn"},
                        "103": {"description": "NVJPG5 Error", "severity": "Warn"},
                        "104": {"description": "NVJPG6 Error", "severity": "Warn"},
                        "105": {"description": "NVJPG7 Error", "severity": "Warn"},
                        "106": {"description": "SMBPBI Test Message", "severity": "Warn"},
                        "107": {"description": "SMBPBI Test Message Silent", "severity": "Warn"},
                        "108": {"description": "Reserved", "severity": "Warn"},
                        "109": {"description": "Context Switch Timeout Error", "severity": "Critical"},
                        "110": {"description": "Security Fault Error", "severity": "Warn"},
                        "111": {"description": "Display Bundle Error Event", "severity": "Warn"},
                        "112": {"description": "Display Supervisor Error", "severity": "Warn"},
                        "113": {"description": "DP Link Training Error", "severity": "Warn"},
                        "114": {"description": "Display Pipeline Underflow Error", "severity": "Warn"},
                        "115": {"description": "Display Core Channel Error", "severity": "Warn"},
                        "116": {"description": "Display Window Channel Error", "severity": "Warn"},
                        "117": {"description": "Display Cursor Channel Error", "severity": "Warn"},
                        "118": {"description": "Display Pixel Pipeline Error", "severity": "Warn"},
                        "119": {"description": "GSP RPC Timeout", "severity": "Critical"},
                        "120": {"description": "GSP Error", "severity": "Critical"},
                        "121": {"description": "C2C Link Error", "severity": "Critical"},
                        "122": {"description": "SPI PMU RPC Read Failure", "severity": "Warn"},
                        "123": {"description": "SPI PMU RPC Write Failure", "severity": "Warn"},
                        "124": {"description": "SPI PMU RPC Erase Failure", "severity": "Warn"},
                        "125": {"description": "Inforom FS Failure", "severity": "Warn"},
                        "126": {"description": "Reserved", "severity": "Warn"},
                        "127": {"description": "Reserved", "severity": "Warn"},
                        "128": {"description": "Reserved", "severity": "Warn"},
                        "129": {"description": "Reserved", "severity": "Warn"},
                        "130": {"description": "Reserved", "severity": "Warn"},
                        "131": {"description": "Reserved", "severity": "Warn"},
                        "132": {"description": "Reserved", "severity": "Warn"},
                        "133": {"description": "Reserved", "severity": "Warn"},
                        "134": {"description": "Reserved", "severity": "Warn"},
                        "135": {"description": "Reserved", "severity": "Warn"},
                        "136": {"description": "Reserved", "severity": "Warn"},
                        "137": {"description": "Reserved", "severity": "Warn"},
                        "138": {"description": "Reserved", "severity": "Warn"},
                        "139": {"description": "Reserved", "severity": "Warn"},
                        "140": {"description": "Unrecovered ECC Error", "severity": "Warn"},
                        "141": {"description": "Reserved", "severity": "Warn"},
                        "142": {"description": "Reserved", "severity": "Warn"},
                        "143": {"description": "GPU Initialization Failure", "severity": "Warn"}
                        }

            def check_gpu_xid(self):
                status = "Pass"
                dmesg_output = subprocess.check_output([self.dmesg_cmd]).decode("utf-8")
                if "NVRM: Xid" in dmesg_output:
                    for XID in self.XID_EC.keys():
                        logger.debug(f"Checking for GPU Xid {XID} error in dmesg")
                        
                        matches = re.findall(f"NVRM: Xid \(PCI:(.*?): {XID},", dmesg_output)
                        tmp_dict = {}
                        for match in matches:
                            if match not in tmp_dict:
                                tmp_dict[match] = 1
                            else:
                                tmp_dict[match] = tmp_dict[match] + 1
                        for x in tmp_dict.keys():
                            logger.info(f"{XID} : count: {tmp_dict[x]}, {self.XID_EC[XID]['description']} - PCI: {x}")
                        if not matches:
                            logger.debug(f"No GPU Xid {XID} error found in dmesg")
                        if tmp_dict != {}:
                            if self.XID_EC[XID]['severity'] == "Critical":
                                status = "Failed"
                            self.results[XID] = {"results": tmp_dict, "description": self.XID_EC[XID]['description']}
                else:
                    logger.info("Xid Check: Passed")
                return {"status": status, "results": self.results}


        if __name__ == '__main__':
            # Argument parsing
            parser = argparse.ArgumentParser(description='Check for GPU Xid errors.')
            parser.add_argument('--dmesg_cmd', default='dmesg', help='Dmesg file to check. Default is dmesg.')
            args = parser.parse_args()


            logger.debug(f"Using dmesg command: {args.dmesg_cmd}")
            
            xc = XidChecker(dmesg_cmd=args.dmesg_cmd)
            results = xc.check_gpu_xid()
            logger.debug("Status: {}, Results: {}".format(results["status"], results["results"]))

    shared_logging.py: |
        #!/usr/bin/env python3

        import logging
        logging.basicConfig(level="INFO", format='%(asctime)s - %(levelname)s - %(message)s')
        logger = logging.getLogger('nhc')

    oke_healthcheck.sh: |
        #!/bin/bash
        
        readonly OK=0
        readonly NONOK=1
        readonly UNKNOWN=2
        
        healthcheck_type=$1
        healtcheck_log_file=/host/tmp/oke-latest-${healthcheck_type}-healthcheck.log
        shape=$(chroot /host bash -c 'curl -sH "Authorization: Bearer Oracle" -L http://169.254.169.254/opc/v2/instance/shape')

        # FILES=$(ls ./custom-config/*.py)
        cp ./custom-config/*.py /host/tmp

        # Check if OCA RDMA config & auth plugins are enabled
        if chroot /host bash -c '/tmp/oke_healthcheck.py --oca-rdma-plugin-status 2>&1 | grep -q "OCA RDMA Plugins are enabled"'; then
            is_rdma_enabled=1
        else
            is_rdma_enabled=0
        fi        
        
        # If OCA RDMA plugins are not enabled, do not run the RDMA related tests
        if [ $is_rdma_enabled -ne 1 ] && ([ $healthcheck_type = "rdma-link" ] || [ $healthcheck_type = "rdma-link-flapping" ] || [ $healthcheck_type = "rdma-wpa-auth" ] || [ $healthcheck_type = "rdma-rttcc" ])
        then
            echo "Instance is not RDMA enabled"
            exit $OK
        else
            chroot /host bash -c "/tmp/oke_healthcheck.py --short --$healthcheck_type > /tmp/oke-latest-${healthcheck_type}-healthcheck.log 2>&1"
        fi
        
        ERROR_MSG=$(cat "$healtcheck_log_file" | grep "Healthcheck::")
        UNKNOWN_MSG=$(cat "$healtcheck_log_file" | grep -o 'Skipping.*')
        
        if [ "$ERROR_MSG" != "" ]
        then
            echo "${ERROR_MSG#* }"
            exit $NONOK
        elif [ "$ERROR_MSG" == "" ] && [ "$UNKNOWN_MSG" != "" ]
        then
            echo $UNKNOWN_MSG
            exit $UNKNOWN
        else
            echo "No errors found"
            exit $OK
        fi    

  log_monitors:
    - /config/kernel-monitor.json
    - /config/docker-monitor.json
    - /config/readonly-monitor.json
    # An example of activating a custom log monitor definition in
    # Node Problem Detector
    # - /custom-config/docker-monitor-filelog.json
  custom_plugin_monitors:
    - /custom-config/oke-gpu-ecc.json
    - /custom-config/oke-gpu-remap.json
    - /custom-config/oke-gpu-bus.json
    - /custom-config/oke-gpu-count.json
    - /custom-config/oke-rdma-link.json
    - /custom-config/oke-rdma-link-flapping.json
    - /custom-config/oke-rdma-wpa-auth.json
    - /custom-config/oke-rdma-rttcc.json
    - /custom-config/oke-oca-version.json
    - /custom-config/oke-gpu-pcie.json
    - /custom-config/oke-gpu-fabric-mgr.json
    - /custom-config/oke-gpu-bad-pages.json
    - /custom-config/oke-cpu-profile.json  

  # Any extra arguments to append to node-problem-detector command
  # - "--port 20526"
  extraArgs: []

  # settings.prometheus_address -- Prometheus exporter address
  prometheus_address: 0.0.0.0
  # settings.prometheus_port -- Prometheus exporter port
  prometheus_port: 20257

  # The period at which k8s-exporter does forcibly sync with apiserver
  # settings.heartBeatPeriod -- Syncing interval with API server
  heartBeatPeriod: 5m0s

logDir:
  # logDir.host -- log directory on k8s host
  host: /var/log/
  # logDir.pod -- log directory in pod (volume mount), use logDir.host if empty
  pod: ""

image:
  repository: registry.k8s.io/node-problem-detector/node-problem-detector
  tag: v0.8.20
  # image.digest -- the image digest. If given it takes precedence over a given tag.
  digest: ""
  pullPolicy: IfNotPresent

imagePullSecrets: []

nameOverride: ""
fullnameOverride: "gpu-rdma-node-problem-detector"

rbac:
  create: true
  pspEnabled: false

# hostNetwork -- Run pod on host network
# Flag to run Node Problem Detector on the host's network. This is typically
# not recommended, but may be useful for certain use cases.
hostNetwork: false
hostPID: false

volume:
  localtime:
    type: "FileOrCreate"

priorityClassName: system-node-critical

securityContext:
  privileged: true

resources: {}

annotations: {}

labels: {}

tolerations:
  - effect: NoSchedule
    operator: Exists

serviceAccount:
  # Specifies whether a ServiceAccount should be created
  create: true
  # Annotations to add to the service account
  annotations: {}
  # Labels to add to the service account
  labels: {}
  # The name of the ServiceAccount to use.
  # If not set and create is true, a name is generated using the fullname template
  name:

affinity:
  nodeAffinity:
    requiredDuringSchedulingIgnoredDuringExecution:
      nodeSelectorTerms:
        - matchExpressions:
            - key: node.kubernetes.io/instance-type
              operator: In
              values:
              - BM.GPU.A100-v2.8
              - BM.GPU.B4.8
              - BM.GPU4.8
              - BM.GPU.H100.8
              - BM.GPU.MI300X.8
              - BM.GPU.L40S-NC.4
              - BM.GPU.A10.4
              - VM.GPU.A10.1
              - VM.GPU.A10.2
              - VM.GPU.A100.80G.1
              - BM.GPU.H200.8

nodeSelector: {}

metrics:
  # metrics.enabled -- Expose metrics in Prometheus format with default configuration.
  enabled: true
  # metrics.annotations -- Override all default annotations when `metrics.enabled=true` with specified values.
  annotations: {}
  serviceMonitor:
    enabled: true
    attachMetadata:
      node: true
    additionalLabels:
      release: kube-prometheus-stack
    additionalRelabelings:
      - sourceLabels: [__meta_kubernetes_node_provider_id]
        targetLabel: instance_id
        action: replace
      - sourceLabels: [__meta_kubernetes_node_label_oci_oraclecloud_com_host_serial_number]
        targetLabel: host_serial_number
        action: replace
      - sourceLabels: [__meta_kubernetes_node_label_node_kubernetes_io_instance_type]
        targetLabel: instance_shape
        action: replace
      - sourceLabels: [__meta_kubernetes_node_label_displayName]
        targetLabel: display_name
        action: replace        
    metricRelabelings: [] 
  prometheusRule:
    enabled: false
    defaultRules:
      create: false
      disabled: []
    additionalLabels:
      release: kube-prometheus-stack
    additionalRules: []
                              
extraVolumes:
  - name: root
    hostPath:
      path: /

extraVolumeMounts:
  - name: root
    mountPath: /host

extraContainers: []

# updateStrategy -- Manage the daemonset update strategy
updateStrategy: RollingUpdate
# maxUnavailable -- The max pods unavailable during an update
maxUnavailable: 1