settings:
  # Custom monitor definitions to add to Node Problem Detector - to be
  # mounted at /custom-config. These are in addition to pre-packaged monitor
  # definitions provided within the default docker image available at /config:
  # https://github.com/kubernetes/node-problem-detector/tree/master/config
  # settings.custom_monitor_definitions -- Custom plugin monitor config files
  custom_monitor_definitions:
    oke-gpu-ecc.json: |
        {
        "plugin": "custom",
        "pluginConfig": {
            "invoke_interval": "300s",
            "timeout": "30s",
            "max_output_length": 80,
            "concurrency": 1,
            "enable_message_change_based_condition_update": false
        },
        "source": "oke-gpu-ecc.json",
        "metricsReporting": true,
        "conditions": [
            {
            "type": "GpuEcc",
            "reason": "GpuEccHasNoIssues",
            "message": "No ECC issues detected with GPUs"
            }
        ],
        "rules": [
            {
            "type": "permanent",
            "condition": "GpuEcc",
            "reason": "GpuEccHasIssues",
            "path": "./custom-config/oke_healthcheck.sh",
            "args": [ "gpu-ecc" ],
            "timeout": "30s"
            }
        ]
        }
    oke-gpu-remap.json: |
        {
        "plugin": "custom",
        "pluginConfig": {
            "invoke_interval": "300s",
            "timeout": "30s",
            "max_output_length": 80,
            "concurrency": 1,
            "enable_message_change_based_condition_update": false
        },
        "source": "oke-gpu-remap.json",
        "metricsReporting": true,
        "conditions": [
            {
            "type": "GpuRowRemap",
            "reason": "GpuRowRemapHasNoIssues",
            "message": "No Row Remapping issues detected with GPUs"
            }
        ],
        "rules": [
            {
            "type": "permanent",
            "condition": "GpuRowRemap",
            "reason": "GpuRowRemapHasIssues",
            "path": "./custom-config/oke_healthcheck.sh",
            "args": [ "gpu-row-remap" ],        
            "timeout": "30s"
            }
        ]
        }

    oke-gpu-bus.json: |
        {
        "plugin": "custom",
        "pluginConfig": {
            "invoke_interval": "300s",
            "timeout": "30s",
            "max_output_length": 80,
            "concurrency": 1,
            "enable_message_change_based_condition_update": false
        },
        "source": "oke-gpu-bus.json",
        "metricsReporting": true,
        "conditions": [
            {
            "type": "GpuBus",
            "reason": "GpuBusHasNoIssues",
            "message": "No GPU Bus issues detected with GPUs"
            }
        ],
        "rules": [
            {
            "type": "permanent",
            "condition": "GpuBus",
            "reason": "GpuBusHasIssues",
            "path": "./custom-config/oke_healthcheck.sh",
            "args": [ "gpu-bus" ],        
            "timeout": "30s"
            }
        ]
        }
    
    oke-gpu-count.json: |
        {
        "plugin": "custom",
        "pluginConfig": {
            "invoke_interval": "300s",
            "timeout": "30s",
            "max_output_length": 80,
            "concurrency": 1,
            "enable_message_change_based_condition_update": false
        },
        "source": "oke-gpu-count.json",
        "metricsReporting": true,
        "conditions": [
            {
            "type": "GpuCount",
            "reason": "GpuCountHasNoIssues",
            "message": "Node has the expected number of GPUs"
            }
        ],
        "rules": [
            {
            "type": "permanent",
            "condition": "GpuCount",
            "reason": "GpuCountHasIssues",
            "path": "./custom-config/oke_healthcheck.sh",
            "args": [ "gpu-count" ],        
            "timeout": "30s"
            }
        ]
        }    
    
    oke-rdma-link.json: |
        {
        "plugin": "custom",
        "pluginConfig": {
            "invoke_interval": "300s",
            "timeout": "30s",
            "max_output_length": 80,
            "concurrency": 1,
            "enable_message_change_based_condition_update": false
        },
        "source": "oke-rdma-link.json",
        "metricsReporting": true,
        "conditions": [
            {
            "type": "RdmaLink",
            "reason": "RdmaLinkHasNoIssues",
            "message": "All RDMA links are up"
            }
        ],
        "rules": [
            {
            "type": "permanent",
            "condition": "RdmaLink",
            "reason": "RdmaLinkHasIssues",
            "path": "./custom-config/oke_healthcheck.sh",
            "args": [ "rdma-link" ],        
            "timeout": "30s"
            }
        ]
        }    

    oke-rdma-link-flapping.json: |
        {
        "plugin": "custom",
        "pluginConfig": {
            "invoke_interval": "300s",
            "timeout": "30s",
            "max_output_length": 80,
            "concurrency": 1,
            "enable_message_change_based_condition_update": false
        },
        "source": "oke-rdma-link-flapping.json",
        "metricsReporting": true,
        "conditions": [
            {
            "type": "RdmaLinkFlapping",
            "reason": "RdmaLinkFlappingHasNoIssues",
            "message": "No flapping RDMA links"
            }
        ],
        "rules": [
            {
            "type": "permanent",
            "condition": "RdmaLinkFlapping",
            "reason": "RdmaLinkFlappingHasIssues",
            "path": "./custom-config/oke_healthcheck.sh",
            "args": [ "rdma-link-flapping" ],        
            "timeout": "30s"
            }
        ]
        }   

    oke-rdma-wpa-auth.json: |
        {
        "plugin": "custom",
        "pluginConfig": {
            "invoke_interval": "300s",
            "timeout": "30s",
            "max_output_length": 80,
            "concurrency": 1,
            "enable_message_change_based_condition_update": false
        },
        "source": "oke-rdma-wpa-auth.json",
        "metricsReporting": true,
        "conditions": [
            {
            "type": "RdmaWpaAuth",
            "reason": "RdmaWpaAuthHasNoIssues",
            "message": "All RDMA links are authenticated"
            }
        ],
        "rules": [
            {
            "type": "permanent",
            "condition": "RdmaWpaAuth",
            "reason": "RdmaWpaAuthHasIssues",
            "path": "./custom-config/oke_healthcheck.sh",
            "args": [ "rdma-wpa-auth" ],        
            "timeout": "30s"
            }
        ]
        }   

    oke-rdma-rttcc.json: |
        {
        "plugin": "custom",
        "pluginConfig": {
            "invoke_interval": "300s",
            "timeout": "30s",
            "max_output_length": 80,
            "concurrency": 1,
            "enable_message_change_based_condition_update": false
        },
        "source": "oke-rdma-rttcc.json",
        "metricsReporting": true,
        "conditions": [
            {
            "type": "RdmaRttcc",
            "reason": "RdmaRttccHasNoIssues",
            "message": "RTCCC is disabled on all RDMA interfaces"
            }
        ],
        "rules": [
            {
            "type": "permanent",
            "condition": "RdmaRttcc",
            "reason": "RdmaRttccHasIssues",
            "path": "./custom-config/oke_healthcheck.sh",
            "args": [ "rdma-rttcc" ],        
            "timeout": "30s"
            }
        ]
        }   

    oke-oca-version.json: |
        {
        "plugin": "custom",
        "pluginConfig": {
            "invoke_interval": "300s",
            "timeout": "30s",
            "max_output_length": 80,
            "concurrency": 1,
            "enable_message_change_based_condition_update": false
        },
        "source": "oke-oca-version.json",
        "metricsReporting": true,
        "conditions": [
            {
            "type": "OcaVersion",
            "reason": "OcaVersionHasNoIssues",
            "message": "OCA version is up to date"
            }
        ],
        "rules": [
            {
            "type": "permanent",
            "condition": "OcaVersion",
            "reason": "OcaVersionHasIssues",
            "path": "./custom-config/oke_healthcheck.sh",
            "args": [ "oca-version" ],        
            "timeout": "30s"
            }
        ]
        }   

    oke_healthcheck.py: |
      #!/usr/bin/env python3
      
      import subprocess
      import re
      import argparse
      from datetime import datetime
      from shared_logging import logger
      #from gpu_bw_test import BandwidthTest
      from rdma_link_flapping import LinkFlappingTest
      from xid_checker import XidChecker
      import platform
      import os
      import requests
      
      def get_metadata():
          """ Make a request to metadata endpoint """
          headers = { 'Authorization' : 'Bearer Oracle' }
          metadata_url = "http://169.254.169.254/opc/"
          metadata_ver = "2"
          request_url = metadata_url + "v" + metadata_ver + "/instance/"
          return requests.get(request_url, headers=headers).json()
      
      def is_user_root():
          # Check if the user is root
          if os.geteuid() != 0:
              logger.debug("User is root")
              return False
          return True
      
      def get_oca_version():
          # Run the shell command
          os_name = platform.system()
      
      
          if os_name == 'Linux':
              try:
                  distro = platform.linux_distribution()[0]
              except:
                  import distro
                  distro = distro.name()
      
              if 'Ubuntu' in distro:
                  if not is_user_root():
                      result = subprocess.run(['sudo', 'snap', 'info', 'oracle-cloud-agent'], stdout=subprocess.PIPE)
                  else:
                      result = subprocess.run(['snap', 'info', 'oracle-cloud-agent'], stdout=subprocess.PIPE)
      
                  # Decode the output from bytes to string
                  output = result.stdout.decode('utf-8')
      
                  # Define the regular expression pattern for the version
                  pattern = r'installed:\s+(\d+\.\d+\.\d+)'
                  match = re.search(pattern, output)
                  if match:
                      version = match.group(1)
      
              elif 'Oracle' in distro:
                  result = subprocess.run(['rpm', '-qa'], stdout=subprocess.PIPE)
      
                  # Decode the output from bytes to string
                  output = result.stdout.decode('utf-8')
      
                  # Define the regular expression pattern for the version
                  pattern = r'oracle-cloud-agent-(\d+\.\d+\.\d+)'
                  match = re.search(pattern, output)
                  if match:
                      version = match.group(1)
      
      
              if version < "1.39.0":
                  logger.error(f"Oracle Cloud Agent: {version} needs to be updated to 1.39.0 or higher")
              else:
                  logger.info(f"Oracle Cloud Agent: {version}")
      
              # Return the version
              return version
      
      def check_oca_rdma_plugin_status():
          metadata=get_metadata()
          plugins_config = metadata.get('agentConfig', {}).get('pluginsConfig', [])
          enabled_plugins = {plugin['name']: plugin['desiredState'] for plugin in plugins_config}
      
          is_rdma_auto_configuration_enabled = enabled_plugins.get('Compute HPC RDMA Auto-Configuration') == 'ENABLED'
          is_rdma_authentication_enabled = enabled_plugins.get('Compute HPC RDMA Authentication') == 'ENABLED'
          
          if all([is_rdma_auto_configuration_enabled, is_rdma_authentication_enabled]):
              logger.info(f"OCA RDMA Plugins are enabled")
          else:
              logger.info(f"OCA RDMA Plugins are disabled")
          return all([is_rdma_auto_configuration_enabled, is_rdma_authentication_enabled])
      
      def check_rttcc_status():
          link_status = []
          metadata=get_metadata()
          shape=metadata['shape']
          if shape == "BM.GPU.H100.8":
              devices = ["mlx5_0", "mlx5_1", "mlx5_3", "mlx5_4", "mlx5_5", "mlx5_6", "mlx5_7", "mlx5_8", "mlx5_9", "mlx5_10", "mlx5_12", "mlx5_13", "mlx5_14", "mlx5_15", "mlx5_16", "mlx5_17"]
          elif shape == "BM.GPU.B4.8" or shape == "BM.GPU.A100-v2.8":
              devices = ["mlx5_1", "mlx5_2", "mlx5_3", "mlx5_4", "mlx5_5", "mlx5_6", "mlx5_7", "mlx5_8", "mlx5_9", "mlx5_10", "mlx5_11", "mlx5_12", "mlx5_14", "mlx5_15", "mlx5_16", "mlx5_17"]
          elif shape == "BM.GPU4.8":
              devices = ["mlx5_0", "mlx5_1", "mlx5_2", "mlx5_3", "mlx5_6", "mlx5_7", "mlx5_8", "mlx5_9", "mlx5_10", "mlx5_11", "mlx5_12", "mlx5_13", "mlx5_14", "mlx5_15", "mlx5_16", "mlx5_17"]
          elif shape == "BM.GPU.MI300X.8":
              devices = ["mlx5_0", "mlx5_2", "mlx5_3", "mlx5_4", "mlx5_5", "mlx5_7", "mlx5_8", "mlx5_9"]
          status = "disabled"
          status_dict = {"devices": {}}
          for device in devices:
              if not is_user_root():
                  command = ['sudo', 'mlxreg', '-d', device, '-y', '--get', '--reg_name=PPCC', '--indexes=local_port=1,pnat=0,lp_msb=0,algo_slot=0,algo_param_index=0']
              else:
                  command = ['mlxreg', '-d', device, '-y', '--set', 'cmd_type=3', '--reg_name=PPCC', '--indexes=local_port=1,pnat=0,lp_msb=0,algo_slot=0,algo_param_index=0']
              result = subprocess.run(command, stdout=subprocess.PIPE,stderr=subprocess.PIPE)
              output = result.stdout.decode('utf-8')
              filtered_output = [line for line in output.split('\n') if line.startswith('value')]
              for line in filtered_output:
                  logger.debug(line)
                  if "0x00000001" in line:
                      status_dict["devices"][device] = "enabled"
      
          for device in status_dict["devices"]:
              if status_dict["devices"][device] == "enabled":
                  logger.warning(f"RTTCC enabled on {device}")
                  status = "enabled"
                  link_status.append(f"RTTCC enabled on: {device}")
              else:
                  logger.info(f"RTTCC status for {device}: disabled")
          if status == "disabled":
              logger.info(f"RTTCC disabled check: Passed")
          else:
              logger.error(f"RTTCC disabled check: Failed")
      
          return link_status
      
      def check_ecc_errors():
          ecc_issues = []
          try:
              # Run the nvidia-smi -q command
              result = subprocess.run(['nvidia-smi', '-q'], stdout=subprocess.PIPE)
          except FileNotFoundError:
              logger.warning("Skipping SRAM/DRAM ECC Test: nvidia-smi command not found")
              return []
      
          # Decode the output from bytes to string
          output = result.stdout.decode('utf-8')
      
          # Find the lines containing "SRAM Correctable" and "DRAM Correctable"
          sram_matches = re.findall(r'SRAM Uncorrectable\s+:\s+(\d+)', output)
          if len(sram_matches)==0:
              sram_matches = re.findall(r'SRAM Uncorrectable Parity\s+:\s+(\d+)', output)
          dram_matches = re.findall(r'DRAM Uncorrectable\s+:\s+(\d+)', output)
          gpu_matches = re.findall(r'\nGPU\s+(.*)\n', output)
          vol_sram_line = sram_matches[0::2]
          vol_dram_line = dram_matches[0::2]
          agg_sram_line = sram_matches[1::2]
          agg_dram_line = dram_matches[1::2]
      
          for i, gpu in enumerate(gpu_matches):
              logger.debug(f"GPU: {gpu}")
              if vol_sram_line[i] != "0":
                  logger.debug(f"Volatile SRAM Uncorrectable: {vol_sram_line[i]}")
                  ecc_issues.append(f"{gpu_matches[i]} - Volatile SRAM Uncorrectable: {vol_sram_line[i]}")
              if vol_dram_line[i] != "0":
                  logger.debug(f"Volatile DRAM Uncorrectable: {vol_dram_line[i]}")
                  ecc_issues.append(f"{gpu_matches[i]} - Volatile DRAM Uncorrectable: {vol_dram_line[i]}")
              if agg_sram_line[i] != "0":
                  logger.debug(f"Aggregate SRAM Uncorrectable: {agg_sram_line[i]}")
                  ecc_issues.append(f"{gpu_matches[i]} - Aggregate SRAM Uncorrectable: {agg_sram_line[i]}")
              if agg_dram_line[i] != "0":
                  logger.debug(f"Aggregate DRAM Uncorrectable: {agg_dram_line[i]}")
                  ecc_issues.append(f"{gpu_matches[i]} - Aggregate DRAM Uncorrectable: {agg_dram_line[i]}")
      
      
          # Check if there are ecc_issues
          if len(ecc_issues) == 0:
              logger.info("GPU ECC Test: Passed")
          else:
              logger.warning("GPU ECC Test: Failed")
      
          return ecc_issues
      
      def check_row_remap_errors():
          remap_issues = []
          try:
              # Run the nvidia-smi -q command
              result = subprocess.run(['nvidia-smi', '--query-remapped-rows=remapped_rows.pending,remapped_rows.failure,remapped_rows.uncorrectable', '--format=csv,noheader'], stdout=subprocess.PIPE)
      
              if result.returncode != 0:
                  logger.debug(f"Check row remap command exited with error code: {result.returncode}")
      
          except FileNotFoundError:
              logger.warning("Skipping Row Remap Test: nvidia-smi command not found")
              return []
      
          # Decode the output from bytes to string
          output = result.stdout.decode('utf-8')
          logger.debug("Output: {}".format(output))
          for i, line in enumerate(output.split('\n')):
              if line == "":
                  continue
              tmp_data = line.split(",")
              tmp_data = [x.strip() for x in tmp_data]
              if tmp_data[0] != "0" and tmp_data[0] != "No":
                  logger.debug(f"GPU: {i} - Row Remap Pending: {tmp_data[0]}")
                  remap_issues.append(f"GPU: {i} Row Remap Pending: {tmp_data[0]}")
              if tmp_data[1] != "0" and tmp_data[0] != "No":
                  logger.debug(f"GPU: {i} - Row Remap Failure: {tmp_data[1]}")
                  #remap_issues.append(f"GPU: {i} Row Remap Failure: {tmp_data[1]}")
              if tmp_data[2] != "0" and tmp_data[0] != "No":
                  logger.debug(f"GPU: {i} - Row Remap Uncorrectable: {tmp_data[2]}")
                  if int(tmp_data[2]) > 512:
                      remap_issues.append(f"GPU: {i} - Row Remap Uncorrectable >512: {tmp_data[2]}")
                  else:
                      remap_issues.append(f"GPU: {i} - Row Remap Uncorrectable <512: {tmp_data[2]}")# Check if there are ecc_issues
      
          if len(remap_issues) == 0:
              logger.info("GPU Remap Test: Passed")
          else:
              logger.warning("GPU Remap Test: Failed")
      
          return remap_issues
      
      def check_rdma_link_status():
          status = True
          metadata=get_metadata()
          shape=metadata['shape']
          if shape == "BM.GPU.H100.8":
              devices = ["mlx5_0", "mlx5_1", "mlx5_3", "mlx5_4", "mlx5_5", "mlx5_6", "mlx5_7", "mlx5_8", "mlx5_9", "mlx5_10", "mlx5_12", "mlx5_13", "mlx5_14", "mlx5_15", "mlx5_16", "mlx5_17"]
          elif shape == "BM.GPU.B4.8" or shape == "BM.GPU.A100-v2.8":
              devices = ["mlx5_1", "mlx5_2", "mlx5_3", "mlx5_4", "mlx5_5", "mlx5_6", "mlx5_7", "mlx5_8", "mlx5_9", "mlx5_10", "mlx5_11", "mlx5_12", "mlx5_14", "mlx5_15", "mlx5_16", "mlx5_17"]
          elif shape == "BM.GPU4.8":
              devices = ["mlx5_0", "mlx5_1", "mlx5_2", "mlx5_3", "mlx5_6", "mlx5_7", "mlx5_8", "mlx5_9", "mlx5_10", "mlx5_11", "mlx5_12", "mlx5_13", "mlx5_14", "mlx5_15", "mlx5_16", "mlx5_17"]
          elif shape == "BM.GPU.MI300X.8":
              devices = ["mlx5_0", "mlx5_2", "mlx5_3", "mlx5_4", "mlx5_5", "mlx5_7", "mlx5_8", "mlx5_9"]    
          link_issues = []
          for device in devices:
              # Run the mlxlink command
              if not is_user_root():
                  command = ['sudo', 'mlxlink', '-d', device, '-m', '-c', '-e']
              else:
                  command = ['mlxlink', '-d', device, '-m', '-c', '-e']
              result = subprocess.run(command, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
      
              # Decode the output from bytes to string
              output = result.stdout.decode('utf-8')
              stderr = result.stderr.decode('utf-8')
      
              if stderr and stderr.find("-E-") != -1:
                  stderr = stderr.split("\n")
                  stderr_line = ", ".join(stderr)
                  logger.debug(f"{device}: {stderr_line}")
                  link_issues.append(f"{device}: {stderr[0]}")
                  status = "False"
                  continue
      
              # Find the line containing "Recommendation"
              color_pattern = re.compile(r'\x1B(?:[@-Z\\-_]|\[[0-?]*[ -/]*[@-~])')
              link_state = re.search(r'\nState.*', output).group().split(":")[1].strip()
              recommendation = re.search(r'Recommendation.*', output).group().split(":")[1].strip()
              vendor_serial_num = re.search(r'Vendor Serial Number.*', output).group().split(":")[1].strip()
              nic_fw_version = re.search(r'Firmware Version.*', output).group().split(":")[1].strip()
              cable_fw_version = re.search(r'FW Version.*', output).group().split(":")[1].strip()
              physical_BER = re.search(r'Raw Physical BER.*', output).group().split(":")[1].strip()
              # Remove hidden characters from the output
              link_state = re.sub(color_pattern, '', link_state)
              nic_fw_version = re.sub(color_pattern, '', nic_fw_version)
              recommendation = re.sub(color_pattern, '', recommendation)
      
              logger.debug(f"{device}: {vendor_serial_num} - {cable_fw_version} - {nic_fw_version} - {link_state} - {recommendation}")
      
              # Extract the part after the ":" and print it along with the device name
              if link_state != "Active":
                  logger.debug(f"{device}: {link_state}")
                  link_issues.append(f"{device} - {vendor_serial_num} - {cable_fw_version} - {nic_fw_version}: {link_state}")
                  status = False
              if not "No issue was observed" in recommendation:
                  logger.debug(f"{device}: {recommendation}")
                  if "Bad signal integrity" in recommendation and float(physical_BER) < 1e-07:
                      logger.debug(f"Recommandation is {recommendation} but the Physical error are low enough that it can be ignored")
                  else : 
                      logger.debug(f"Recommandation is {recommendation} and the Physical error count is too high to be ignored: {physical_BER}")
                      link_issues.append(f"{device} - {vendor_serial_num} - {cable_fw_version} - {nic_fw_version}: {recommendation}")
                      status = False
              else:
                  logger.debug(f"{device}: {recommendation}")
      
          if status:
              logger.info(f"RDMA Link Status Check: Passed")
          else:
              logger.warning(f"RDMA Link Status Check: Failed")
          return link_issues
      
      def get_host_serial():
          # Run the shell command
          if not is_user_root():
              result = subprocess.run(['sudo', 'dmidecode', '-s', 'system-serial-number'], stdout=subprocess.PIPE)
          else:
              result = subprocess.run(['dmidecode', '-s', 'system-serial-number'], stdout=subprocess.PIPE)
      
          # Decode the output from bytes to string
          output = result.stdout.decode('utf-8')
      
          # Return the serial number
          return output.strip()
      
      def check_bus():
          # Check to see if any devices have fallen of the bus
          command = ['lspci', '-v']
          result = subprocess.run(command, stdout=subprocess.PIPE)
          output = result.stdout.decode('utf-8')
          lines = output.split('\n')
          bus_issues = []
          for line in lines:
              if line.find('(rev ff)') != -1:
                  bus_issues.append(line)
          if len(bus_issues) > 0:
              logger.error(f"Devices have fallen off the bus")
          else:
              logger.info("No devices have fallen off the bus")
          if len(bus_issues) == 0:
              logger.info("Bus Check Test: Passed")
              return(bus_issues)
          else:
              logger.warning("Bus Check Test: Failed")
              return(bus_issues)
      
      def check_gpu_count():
    
          # Check the number of GPUs
          try:
              metadata=get_metadata()
              shape=metadata['shape']
              if shape == "BM.GPU.H100.8" or shape == "BM.GPU.B4.8" or shape == "BM.GPU.A100-v2.8" or shape == "BM.GPU4.8" or shape == "BM.GPU.MI300X.8":
                  expected_no_gpu = 8
              elif shape == "BM.GPU.A10.4":
                  expected_no_gpu = 4
              elif shape == "VM.GPU.A10.1":
                  expected_no_gpu = 1
              elif shape == "VM.GPU.A10.2":
                  expected_no_gpu = 2          
              
              if shape == "BM.GPU.MI300X.8":
                  result = subprocess.run(['amd-smi', 'list'], stdout=subprocess.PIPE)
                  output = result.stdout.decode('utf-8')
                  gpu_count = output.count("GPU")
                  tmp_results = []
                  if gpu_count == expected_no_gpu:
                      logger.info("GPU Count Test: Passed")
                  else:
                      logger.warning("GPU Count Test: Failed")
                      tmp_results.append(f"Expected {expected_no_gpu} GPUs, found {gpu_count} using amd-smi command")
                  return tmp_results
              else:
                  result = subprocess.run(['nvidia-smi', '--list-gpus'], stdout=subprocess.PIPE)
                  output = result.stdout.decode('utf-8')
                  lines = output.split('\n')
                  tmp_results = []
                  # remove empty lines
                  lines = [line for line in lines if line]
                  if len(lines) == expected_no_gpu:
                      logger.info("GPU Count Test: Passed")
                  else:
                      logger.warning("GPU Count Test: Failed")
                      tmp_results.append(f"Expected {expected_no_gpu} GPUs, found {len(lines)} using nvidia-smi command")
                  return tmp_results
          except FileNotFoundError:
            if shape == "BM.GPU.MI300X.8":
                logger.warning("Skipping GPU count test: amd-smi command not found")
            else:
                logger.warning("Skipping GPU count test: nvidia-smi command not found")
            return None                  
      
      def check_wpa_auth(metadata):
          # Determine the shape and required authenticated count
          shape = metadata.get('shape')
          if shape in ["BM.GPU.H100.8", "BM.GPU.B4.8", "BM.GPU.A100-v2.8", "BM.GPU4.8"]:
              interface_range = range(16)
              required_authenticated = 16
          elif shape == "BM.GPU.MI300X.8":
              interface_range = range(8)
              required_authenticated = 8
          else:
              logger.error("Unsupported machine shape.")
              return ["Unsupported machine shape."]
      
          authenticated_count = 0
          wpa_auth_issues = []
      
          # Check each RDMA interface for WPA authentication status
          for i in interface_range:
              interface = f"rdma{i}"
              try:
                  result = subprocess.run(
                      ["wpa_cli", "status", "-i", interface],
                      capture_output=True, text=True
                  )
                  for line in result.stdout.splitlines():
                      if "Supplicant PAE state" in line:
                          if "AUTHENTICATED" in line:
                              authenticated_count += 1
                          break
              except subprocess.CalledProcessError as e:
                  wpa_auth_issues.append(f"Error checking {interface}: {e}")
                  logger.warning(f"Error checking {interface}: {e}")
      
          # Evaluate and log the final authentication result
          if authenticated_count < required_authenticated:
              wpa_auth_issues.append(f"Only {authenticated_count} interfaces are AUTHENTICATED; expected {required_authenticated}.")
              logger.error("WPA Authentication Check: Failed")
          else:
              logger.info("WPA Authentication Check: Passed")
      
          return wpa_auth_issues if wpa_auth_issues else []
      
      def short_reason(message):
          global short_drain_reason
          global short_error_count
          short_drain_reason+=(message+"\n")
          short_error_count+=1
      
      if __name__ == '__main__':
          parser = argparse.ArgumentParser(description='Check Host setup')
          parser.add_argument("-l", "--log-level", choices=["DEBUG", "INFO", "WARNING", "ERROR", "CRITICAL"], default="INFO", help="Set the logging level default: INFO")
          parser.add_argument('--bw-test', dest='bw_test', action='store_true', default=False, help='Run GPU bandwidth test (default: False)')
          parser.add_argument('--bw-test-exe', dest='bw_test_exe', help='Location to cuda-sampels bandwidthTest')
          parser.add_argument('--lf-interval', dest='lf_interval', default=6, type=int, help='Link flapping interval with no flapping or link down events (default: 6 (hours))')
          parser.add_argument('-a','--all', dest='run_all', action='store_true', default=False, help='Run all checks (default: False)')
          parser.add_argument('-short','--short', dest='short', action='store_true', default=False, help='Add a short message')
          parser.add_argument('-gpu-count','--gpu-count', dest='gpu_count', action='store_true', default=False, help='Run GPU Count check')
          parser.add_argument('-gpu-bus','--gpu-bus', dest='gpu_bus', action='store_true', default=False, help='Run GPU Bus check')
          parser.add_argument('-gpu-ecc','--gpu-ecc', dest='gpu_ecc', action='store_true', default=False, help='Run GPU ECC check')
          parser.add_argument('-gpu-row-remap','--gpu-row-remap', dest='gpu_row_remap', action='store_true', default=False, help='Run GPU Row Remap check')
          parser.add_argument('-gpu-xid','--gpu-xid', dest='gpu_xid', action='store_true', default=False, help='Run GPU XID check')  
          parser.add_argument('-oca-version','--oca-version', dest='oca_version', action='store_true', default=False, help='Run OCA Version check')
          parser.add_argument('-rttcc','--rttcc', dest='rttcc', action='store_true', default=False, help='Run RTTCC check')
          parser.add_argument('-rdma-link','--rdma-link', dest='rdma_link', action='store_true', default=False, help='Run RDMA Link check')
          parser.add_argument('-rdma-link-flapping','--rdma-link-flapping', dest='rdma_link_flapping', action='store_true', default=False, help='Run RDMA Link Flapping check')
          parser.add_argument('-wpa-auth', '--wpa-auth', dest='wpa_auth', action="store_true", default=False, help="Run WPA authentication check")
          parser.add_argument('-oca-rdma-plugin-status', '--oca-rdma-plugin-status', dest='oca_rdma_plugin_status',action="store_true", default=False, help="Check if the RDMA plugins are enabled")
          args = parser.parse_args()
      
          logger.setLevel(args.log_level)
      
          datetime_str = datetime.now().strftime('%Y-%m-%d-%H%M%S')
          logger.info(f"Started GPU host setup check at: {datetime_str}")
          try:
              if args.oca_version == True or args.run_all == True:
               oca_version = get_oca_version()
          except Exception as e:
              logger.warning(f"Failed to get Oracle Cloud Agent version with error: {e}")
              oca_version = "Unknown"
          try:
              if args.rttcc == True or args.run_all == True:
               rttcc_issues = check_rttcc_status()
          except Exception as e:
              logger.warning(f"Failed to check RTTCC status with error: {e}")
              rttcc_issues = []
      
          # Check for ECC errors
          try:
              if args.gpu_ecc == True or args.run_all == True:
               ecc_issues = check_ecc_errors()
          except Exception as e:
              logger.warning(f"Failed to check ECC errors with error: {e}")
              ecc_issues = []
      
          # Check for row remap errors
          try:
              if args.gpu_row_remap == True or args.run_all == True:
               remap_results = check_row_remap_errors()
          except Exception as e:
              logger.warning(f"Failed to check row remap errors with error: {e}")
              remap_results = []
      
          # Check RDMA link status
          try:
              if args.rdma_link == True or args.run_all == True:
               rdma_link_issues = check_rdma_link_status()
          except Exception as e:
              logger.warning(f"Failed to check RDMA link status with error: {e}")
              rdma_link_issues = []
      
          # Check for RDMA link flapping
          lft_issues = []
          try:
              if args.rdma_link_flapping == True or args.run_all == True:
               lft = LinkFlappingTest(time_interval=args.lf_interval)
               lft.get_rdma_link_failures()
               lft_issues = lft.process_rdma_link_flapping()
          except Exception as e:
              logger.warning(f"Failed to check RDMA link flapping with error: {e}")
              lft_issues = {"failures": [], "link_down": []}
      
          # Check for GPU Xid errors
          try:
              if args.gpu_xid == True or args.run_all == True:
               xc = XidChecker()
               xid_results = xc.check_gpu_xid()
          except Exception as e:
              logger.warning(f"Failed to check GPU Xid errors with error: {e}")
              xid_results = {"status": "None", "results": {}}
      
          # Check GPU bandwidth
          bwt_results = None
          try:
              if args.bw_test == True or args.run_all == True:
                  if args.bw_test_exe:
                      bwt = BandwidthTest(bw_test_exe=args.bw_test_exe)
                  else:
                      bwt = BandwidthTest()
                  bwt.measure_gpu_bw()
                  bwt_results = bwt.validate_results()
          except Exception as e:
              logger.warning(f"Failed to check GPU bandwidth with error: {e}")
              bwt_results = None
      
          # Check the bus
          try:
              if args.gpu_bus == True or args.run_all == True:
                  bus_results = check_bus()
          except Exception as e:
              logger.warning(f"Failed to check the bus with error: {e}")
              bus_results = None
      
          # Check the number of GPUs
          try:
              if args.gpu_count == True or args.run_all == True:
                  gpu_results = check_gpu_count()
          except Exception as e:
                  logger.warning(f"Failed to check the number of GPUs with error: {e}")
                  gpu_results = None
      
          # Check WPA authentication if the option is set
          wpa_auth_results = None
          if args.wpa_auth:
              try:
                  metadata = get_metadata()
                  auth_output = check_wpa_auth(metadata)
              except Exception as e:
                  logger.warning(f"Failed to get WPA Authentication status: {e}")
                  wpa_auth_results = None
          
          # Check for OCA RDMA Plugin status
          try:
              if args.oca_rdma_plugin_status == True:
               oca_rdma_plugin_status = check_oca_rdma_plugin_status()
          except Exception as e:
              logger.warning(f"Failed to check OCA RDMA Plugins Status with error: {e}")
              oca_rdma_plugin_status = []
      
          # Summarize the results
          try:
              host_serial = get_host_serial()
          except Exception as e:
              logger.warning(f"Failed to get host serial number with error: {e}")
              host_serial = "Unknown"
      
          short_drain_reason = ""
          short_error_count = 0
      
          logger.info(f"--------- Summary of Host setup check for {host_serial} ---------")
          if args.oca_version == True and oca_version < "1.39.0":
              logger.error(f"Oracle Cloud Agent: {oca_version} needs to be updated to 1.39.0 or higher")
              short_reason("Oracle Cloud Agent: {oca_version} needs to be updated to 1.39.0 or higher")
      
          if args.rttcc == True and len(rttcc_issues) > 0:
              logger.error(f"RTTCC issues: {rttcc_issues}")
              short_reason("RTTCC is not disabled on all RDMA interfaces")
          if args.gpu_ecc == True and len(ecc_issues) > 0:
              ecc_error=False
              for issue in ecc_issues:
                  if "Skipped" in issue:
                      logger.warning(f"{host_serial} - {issue}")
                  else:
                      if "Aggregate" in issue:
                          logger.warning(f"{host_serial} - ECC issues: {issue}")
                      else:
                          logger.error(f"{host_serial} - ECC issues: {issue}")
                          ecc_error=True
              if ecc_error:
                  short_reason("ECC check failed")
          if args.gpu_row_remap == True and len(remap_results) > 0:
              remap_error=False
              for issue in remap_results:
                  if "<512" in issue:
                      logger.warning(f"{host_serial} - {issue}")
                  else:
                      logger.error(f"{host_serial} - {issue}")
                      remap_error=True
              if remap_error:
                  short_reason("Remap check failed")
          if args.gpu_xid == True and xid_results["status"] == "Failed":
              for xid in xid_results["results"]:
                  for pci in xid_results["results"][xid]["results"]:
                      logger.error(f"{host_serial} - GPU Xid {xid} device: {pci}, {xid_results['results'][xid]['description']}")
                      short_reason("XID check failed")
          if args.rdma_link == True and len(rdma_link_issues) > 0:
              for issue in rdma_link_issues:
                  logger.error(f"{host_serial} - RDMA link issues: {issue}")
                  short_reason("RDMA Link check failed")
          if args.rdma_link_flapping == True and (len(lft_issues["failures"]) > 0 or len(lft_issues["link_down"]) > 0):
              if len(lft_issues["failures"]) > 0:
                  for issue in lft_issues["failures"]:
                      logger.error(f"{host_serial} - RDMA link flapping issues: {issue}")
                      short_reason("RDMA Link Flapping check failed")
              if len(lft_issues["link_down"]) > 0:
                  for issue in lft_issues["link_down"]:
                      logger.error(f"{host_serial} - RDMA link down issues: {issue}")
                      short_reason("RDMA Link Down check failed")
          if bwt_results != None:
              if bwt_results["status"] == "Failed":
                  for issue in bwt_results["issues"]:
                      logger.error(f"{host_serial} - GPU bandwidth issues: {issue}")
                      short_reason("GPU Bwt Error")
          if args.gpu_bus == True and bus_results:
              logger.error(f"{host_serial} - Bus issues: {bus_results}")
              short_reason("GPU Bus check failed")
          if args.gpu_count == True and gpu_results:
              logger.error(f"{host_serial} - Missing GPU(s): {gpu_results}")
              short_reason("Node has missing GPU(s)")
      
          if args.wpa_auth == True and wpa_auth_results:
              for issue in wpa_auth_results:
                  logger.error(f"{host_serial} - WPA authentication issue: {issue}")
              short_reason("WPA Auth Error")    
      
          datetime_str = datetime.now().strftime('%Y-%m-%d-%H%M%S')
          logger.info(f"Finished GPU host setup check at: {datetime_str}")
      
          if short_error_count > 0 and args.short:
              print("Healthcheck:: "+short_drain_reason[:-1])
    rdma_link_flapping.py: |
            #!/usr/bin/env python3

            import os
            import sys
            import time
            import datetime
            import re
            import argparse
            import socket
            import subprocess
            from shared_logging import logger


            class LinkFlappingTest:
                def __init__(self, time_interval=6):
                    self.results = None
                    self.time_interval = int(time_interval)
                    self.link_data = None

                    # Check if the log file exists
                    msg_file = "/var/log/messages"
                    if not os.path.exists(msg_file):
                        msg_file = "/var/log/syslog"
                    self.log_file = msg_file

                def get_rdma_link_failures(self):

                    pattern  = r"(\w{3}\s+\d{1,2}\s+\d{2}:\d{2}:\d{2})\s+\S+\s+wpa_supplicant(?:\[\d+\])?: (\w+): CTRL-EVENT-EAP-FAILURE EAP authentication failed"
                    pattern2 = r"(\w{3}\s+\d{1,2}\s+\d{2}:\d{2}:\d{2})\s+\S+\s+kernel: (?:\[\d+\.\d+\]\s)?mlx5_core \S+ (\w+): Link down"
                    
                    self.link_data = {}
                    with open(self.log_file, "r") as f:
                        for line in f:
                            match = re.search(pattern, line)
                            if match:
                                time_str = match.group(1)
                                interface = match.group(2)
                                logger.debug(f"time: {time_str}, interface: {interface}")
                                if interface not in self.link_data:
                                    self.link_data[interface] = {"failures": [time_str], "link_down": []}
                                else:
                                    self.link_data[interface]["failures"].append(time_str)

                            
                            match = re.search(pattern2, line)
                            if match:
                                time_str = match.group(1)
                                interface = match.group(2)
                                logger.debug(f"time: {time_str}, interface: {interface}")
                                if interface not in self.link_data:
                                    self.link_data[interface] = {"failures": [], "link_down": [time_str]}
                                else:
                                    self.link_data[interface]["link_down"].append(time_str)
                                    
                    logger.debug("Link Data: {}".format(self.link_data))
                    return self.link_data

                def process_rdma_link_flapping(self):

                    link_issues = {"failures": [], "link_down": []}

                    # Get the time stamp when the host came up
                    bootup_time = subprocess.run(['uptime', '-s'], stdout=subprocess.PIPE)
                    bootup_time = bootup_time.stdout.decode('utf-8').strip()
                    bootup_time_str = datetime.datetime.strptime(bootup_time, "%Y-%m-%d %H:%M:%S")
                    bootup_time_sec = int(time.mktime(bootup_time_str.timetuple()))
                    bootup_time_grace_period = bootup_time_sec + 1800

                    status = 0
                    if len(self.link_data) >= 0:
                        current_date = datetime.datetime.now()
                        current_date_str = current_date.strftime("%Y-%b-%d %H:%M:%S")
                        current_date_sec = int(time.mktime(datetime.datetime.strptime(current_date_str, "%Y-%b-%d %H:%M:%S").timetuple()))
                        
                        link_failures = False
                        for interface in self.link_data:
                            if len(self.link_data[interface]["failures"]) > 0:
                                link_failures = True
                                logger.debug(f"{interface}: {len(self.link_data[interface]['failures'])} RDMA link failure entries in {self.log_file}")
                                logger.debug(f"{interface}: {self.link_data[interface]['failures']}")        
                            last_date_failure_str = None

                            if len(self.link_data[interface]["failures"]) > 0:
                                last_date_failure_str = self.link_data[interface]["failures"][-1]
                                last_date_failure = datetime.datetime.strptime(last_date_failure_str, "%b %d %H:%M:%S")

                                # Compare the month of the last failure date with the current month
                                if last_date_failure.month > current_date.month:
                                    # If the last failure month is greater than the current month, subtract one from the current year
                                    last_date_failure = last_date_failure.replace(year=current_date.year - 1)
                                else:
                                    # Otherwise, set the year of the last failure date to the current year
                                    last_date_failure = last_date_failure.replace(year=current_date.year)

                                # Convert the last failure date to seconds since the epoch
                                last_date_failure_sec = int(time.mktime(last_date_failure.timetuple()))
                            
                            if last_date_failure_str != None and last_date_failure_str != current_date_str:
                                diff_secs = current_date_sec - last_date_failure_sec
                                diff_hours = diff_secs // (60 * 60)
                                logger.debug(f"RDMA link ({interface}) failed  {diff_hours} hours ago")

                                logger.debug(f"bootup_time_sec: {bootup_time_sec}, boot_time_grace_period: {bootup_time_grace_period}, current_date_sec: {current_date_sec}, diff_secs: {diff_secs}, diff_hours: {diff_hours}")
                                if diff_hours < self.time_interval and last_date_failure_sec > bootup_time_grace_period:
                                    logger.debug(f"{interface}: one or more RDMA link flapping events within {self.time_interval} hours. Last flapping event: {last_date_failure_str})")
                                    link_issues["failures"].append(f"{interface}: {len(self.link_data[interface]['failures'])}")
                                    status = -1

                        for interface in self.link_data:
                            if len(self.link_data[interface]["link_down"]) > 0:
                                logger.debug(f"{interface}: {len(self.link_data[interface]['link_down'])} RDMA link down entries in {self.log_file}")
                                logger.debug(f"{interface}: {self.link_data[interface]['link_down']}")
                            last_date_down_str = None

                            if len(self.link_data[interface]["link_down"]) > 0:
                                    last_date_down_str = self.link_data[interface]["link_down"][-1]
                                    last_date_down = datetime.datetime.strptime(last_date_down_str, "%b %d %H:%M:%S")

                                    # Compare the month of the last failure date with the current month
                                    if last_date_down.month > current_date.month:
                                        # If the last failure month is greater than the current month, subtract one from the current year
                                        last_date_down = last_date_down.replace(year=current_date.year - 1)
                                    else:
                                        # Otherwise, set the year of the last failure date to the current year
                                        last_date_down = last_date_down.replace(year=current_date.year)

                                    # Convert the last failure date to seconds since the epoch
                                    last_date_down_sec = int(time.mktime(last_date_down.timetuple()))


                            if last_date_down_str != None and last_date_down_str != current_date_str:
                                diff_secs = current_date_sec - last_date_down_sec
                                diff_hours = diff_secs // (60 * 60)
                                logger.debug(f"RDMA link ({interface}) down  {diff_hours} hours ago")
                                
                                logger.debug(f"bootup_time_sec: {bootup_time_sec}, boot_time_grace_period: {bootup_time_grace_period}, current_date_sec: {current_date_sec}, diff_secs: {diff_secs}, diff_hours: {diff_hours}")
                                if diff_hours < self.time_interval and last_date_down_sec > bootup_time_grace_period:
                                    logger.debug(f"{interface}, one or more RDMA link down events within {self.time_interval} hours. Last link down event: {last_date_down_str}")
                                    link_issues["link_down"].append(f"{interface}: {len(self.link_data[interface]['link_down'])}")
                                    status = -2
                        if status == -1:
                            logger.debug(f"One or more RDMA link flapping events within the past {self.time_interval} hours")
                        if status == -2:
                            logger.debug(f"One or more RDMA link down events within the past {self.time_interval} hours")

                    else:
                        logger.info("No RDMA link failures entry in /var/log/messages")
                    if status == 0:    
                        logger.info("RDMA link flapping/down test: Passed")
                    else:
                        logger.warning("RDMA link flapping/down test: Failed")
                    return link_issues


            if __name__ == "__main__":

                parser = argparse.ArgumentParser(description="Process RDMA link flapping data")
                parser.add_argument("-l", "--log-level", choices=["DEBUG", "INFO", "WARNING", "ERROR", "CRITICAL"], default="INFO", help="Set the logging level")
                args = parser.parse_args()

                logger.setLevel(args.log_level)

                auth_failure_file = "/tmp/last_auth_failure_date"
                msg_file = "/var/log/messages"
                if not os.path.exists(msg_file):
                    msg_file = "/var/log/syslog"
                time_interval_hours = 6
                lft = LinkFlappingTest(time_interval=time_interval_hours)
                link_data = lft.get_rdma_link_failures()
                lft.process_rdma_link_flapping()
    xid_checker.py: |
        #!/usr/bin/env python3

        import argparse
        from shared_logging import logger
        import subprocess
        import sys
        import re
        import os

        class XidChecker:
            def __init__(self, dmesg_cmd="dmesg", time_interval=60):
                # if user is root
                if not os.geteuid() == 0:
                    logger.info("The XidChecker script did not run since it must be run as root")
                    sys.exit(1)
                self.dmesg_cmd = dmesg_cmd
                self.results = {}


                # Check for the following GPU Xid errors in dmesg
                self.XID_EC = {
                        "1": {"description": "Invalid or corrupted push buffer stream", "severity": "Critical"},
                        "2": {"description": "Invalid or corrupted push buffer stream", "severity": "Critical"},
                        "3": {"description": "Invalid or corrupted push buffer stream", "severity": "Critical"},
                        "4": {"description": "Invalid or corrupted push buffer stream", "severity": "Critical"},
                        "5": {"description": "Unused", "severity": "Critical"},
                        "6": {"description": "Invalid or corrupted push buffer stream", "severity": "Critical"},
                        "7": {"description": "Invalid or corrupted push buffer address", "severity": "Critical"},
                        "8": {"description": "GPU stopped processing", "severity": "Critical"},
                        "9": {"description": "Driver error programming GPU", "severity": "Critical"},
                        "10": {"description": "Unused", "severity": "Critical"},
                        "11": {"description": "Invalid or corrupted push buffer stream", "severity": "Critical"},
                        "12": {"description": "Driver error handling GPU exception", "severity": "Critical"},
                        "13": {"description": "Graphics Engine Exception", "severity": "Critical"},
                        "14": {"description": "Unused", "severity": "Warn"},
                        "15": {"description": "Unused", "severity": "Warn"},
                        "16": {"description": "Display engine hung", "severity": "Warn"},
                        "17": {"description": "Unused", "severity": "Warn"},
                        "18": {"description": "Bus mastering disabled in PCI Config Space", "severity": "Warn"},
                        "19": {"description": "Display Engine error", "severity": "Warn"},
                        "20": {"description": "Invalid or corrupted Mpeg push buffer", "severity": "Warn"},
                        "21": {"description": "Invalid or corrupted Motion Estimation push buffer", "severity": "Warn"},
                        "22": {"description": "Invalid or corrupted Video Processor push buffer", "severity": "Warn"},
                        "23": {"description": "Unused", "severity": "Warn"},
                        "24": {"description": "GPU semaphore timeout", "severity": "Warn"},
                        "25": {"description": "Invalid or illegal push buffer stream", "severity": "Warn"},
                        "26": {"description": "Framebuffer timeout", "severity": "Warn"},
                        "27": {"description": "Video processor exception", "severity": "Warn"},
                        "28": {"description": "Video processor exception", "severity": "Warn"},
                        "29": {"description": "Video processor exception", "severity": "Warn"},
                        "30": {"description": "GPU semaphore access error", "severity": "Warn"},
                        "31": {"description": "GPU memory page fault", "severity": "Critical"},    
                        "32": {"description": "Invalid or corrupted push buffer stream", "severity": "Warn"},
                        "33": {"description": "Internal micro-controller error", "severity": "Warn"},
                        "34": {"description": "Video processor exception", "severity": "Warn"},
                        "35": {"description": "Video processor exception", "severity": "Warn"},
                        "36": {"description": "Video processor exception", "severity": "Warn"},
                        "37": {"description": "Driver firmware error", "severity": "Warn"},
                        "38": {"description": "Driver firmware error", "severity": "Warn"},
                        "39": {"description": "Unused", "severity": "Warn"},
                        "40": {"description": "Unused", "severity": "Warn"},
                        "41": {"description": "Unused", "severity": "Warn"},
                        "42": {"description": "Video processor exception", "severity": "Warn"},
                        "43": {"description": "GPU stopped processing", "severity": "Warn"},
                        "44": {"description": "Graphics Engine fault during context switch", "severity": "Warn"},
                        "45": {"description": "Preemptive cleanup, due to previous errors -- Most likely to see when running multiple cuda applications and hitting a DBE", "severity": "Warn"},
                        "46": {"description": "GPU stopped processing", "severity": "Warn"},
                        "47": {"description": "Video processor exception", "severity": "Warn"},
                        "48": {"description": "Double Bit ECC Error", "severity": "Critical"}, 
                        "49": {"description": "Unused", "severity": "Warn"},
                        "50": {"description": "Unused", "severity": "Warn"},
                        "51": {"description": "Unused", "severity": "Warn"},
                        "52": {"description": "Unused", "severity": "Warn"},
                        "53": {"description": "Unused", "severity": "Warn"},
                        "54": {"description": "Auxiliary power is not connected to the GPU board", "severity": "Warn"},
                        "55": {"description": "Unused", "severity": "Warn"},
                        "56": {"description": "Display Engine error", "severity": "Critical"},
                        "57": {"description": "Error programming video memory interface", "severity": "Critical"},
                        "58": {"description": "Unstable video memory interface detected", "severity": "Critical"},
                        "59": {"description": "Internal micro-controller error (older drivers)", "severity": "Warn"},
                        "60": {"description": "Video processor exception", "severity": "Warn"},
                        "61": {"description": "Internal micro-controller breakpoint/warning (newer drivers)", "severity": "Warn"},
                        "62": {"description": "Internal micro-controller halt", "severity": "Critical"},
                        "63": {"description": "ECC page retirement or row remapping recording event", "severity": "Critical"},
                        "64": {"description": "ECC page retirement or row remapper recording failure", "severity": "Critical"},
                        "65": {"description": "Video processor exception", "severity": "Critical"},
                        "66": {"description": "Illegal access by driver", "severity": "Warn"},
                        "67": {"description": "Illegal access by driver", "severity": "Warn"},
                        "68": {"description": "NVDEC0 Exception", "severity": "Critical"},
                        "69": {"description": "Graphics Engine class error", "severity": "Critical"},
                        "70": {"description": "CE3: Unknown Error", "severity": "Warn"},
                        "71": {"description": "CE4: Unknown Error", "severity": "Warn"},
                        "72": {"description": "CE5: Unknown Error", "severity": "Warn"},
                        "73": {"description": "NVENC2 Error", "severity": "Critical"},
                        "74": {"description": "NVLINK Error", "severity": "Critical"},
                        "75": {"description": "CE6: Unknown Error", "severity": "Warn"},
                        "76": {"description": "CE7: Unknown Error", "severity": "Warn"},
                        "77": {"description": "CE8: Unknown Error", "severity": "Warn"},
                        "78": {"description": "vGPU Start Error", "severity": "Warn"},
                        "79": {"description": "GPU has fallen off the bus", "severity": "Critical"},
                        "80": {"description": "Corrupted data sent to GPU", "severity": "Critical"},
                        "81": {"description": "VGA Subsystem Error", "severity": "Critical"},
                        "82": {"description": "NVJPGO Error", "severity": "Warn"},
                        "83": {"description": "NVDEC1 Error", "severity": "Warn"},
                        "84": {"description": "NVDEC2 Error", "severity": "Warn"},
                        "85": {"description": "CE9: Unknown Error", "severity": "Warn"},
                        "86": {"description": "OFA Exception", "severity": "Warn"},
                        "87": {"description": "Reserved", "severity": "Warn"},
                        "88": {"description": "NVDEC3 Error", "severity": "Warn"},
                        "89": {"description": "NVDEC4 Error", "severity": "Warn"},
                        "90": {"description": "Reserved", "severity": "Warn"},
                        "91": {"description": "Reserved", "severity": "Warn"},
                        "92": {"description": "High single-bit ECC error rate", "severity": "Critical"},
                        "93": {"description": "Non-fatal violation of provisioned InfoROM wear limit", "severity": "Warn"},
                        "94": {"description": "Contained ECC error", "severity": "Critical"},
                        "95": {"description": "Uncontained ECC error", "severity": "Critical"},
                        "96": {"description": "NVDEC5 Error", "severity": "Warn"},
                        "97": {"description": "NVDEC6 Error", "severity": "Warn"},
                        "98": {"description": "NVDEC7 Error", "severity": "Warn"},
                        "99": {"description": "NVJPG1 Error", "severity": "Warn"},
                        "100": {"description": "NVJPG2 Error", "severity": "Warn"},
                        "101": {"description": "NVJPG3 Error", "severity": "Warn"},
                        "102": {"description": "NVJPG4 Error", "severity": "Warn"},
                        "103": {"description": "NVJPG5 Error", "severity": "Warn"},
                        "104": {"description": "NVJPG6 Error", "severity": "Warn"},
                        "105": {"description": "NVJPG7 Error", "severity": "Warn"},
                        "106": {"description": "SMBPBI Test Message", "severity": "Warn"},
                        "107": {"description": "SMBPBI Test Message Silent", "severity": "Warn"},
                        "108": {"description": "Reserved", "severity": "Warn"},
                        "109": {"description": "Context Switch Timeout Error", "severity": "Critical"},
                        "110": {"description": "Security Fault Error", "severity": "Warn"},
                        "111": {"description": "Display Bundle Error Event", "severity": "Warn"},
                        "112": {"description": "Display Supervisor Error", "severity": "Warn"},
                        "113": {"description": "DP Link Training Error", "severity": "Warn"},
                        "114": {"description": "Display Pipeline Underflow Error", "severity": "Warn"},
                        "115": {"description": "Display Core Channel Error", "severity": "Warn"},
                        "116": {"description": "Display Window Channel Error", "severity": "Warn"},
                        "117": {"description": "Display Cursor Channel Error", "severity": "Warn"},
                        "118": {"description": "Display Pixel Pipeline Error", "severity": "Warn"},
                        "119": {"description": "GSP RPC Timeout", "severity": "Critical"},
                        "120": {"description": "GSP Error", "severity": "Critical"},
                        "121": {"description": "C2C Link Error", "severity": "Critical"},
                        "122": {"description": "SPI PMU RPC Read Failure", "severity": "Warn"},
                        "123": {"description": "SPI PMU RPC Write Failure", "severity": "Warn"},
                        "124": {"description": "SPI PMU RPC Erase Failure", "severity": "Warn"},
                        "125": {"description": "Inforom FS Failure", "severity": "Warn"},
                        "126": {"description": "Reserved", "severity": "Warn"},
                        "127": {"description": "Reserved", "severity": "Warn"},
                        "128": {"description": "Reserved", "severity": "Warn"},
                        "129": {"description": "Reserved", "severity": "Warn"},
                        "130": {"description": "Reserved", "severity": "Warn"},
                        "131": {"description": "Reserved", "severity": "Warn"},
                        "132": {"description": "Reserved", "severity": "Warn"},
                        "133": {"description": "Reserved", "severity": "Warn"},
                        "134": {"description": "Reserved", "severity": "Warn"},
                        "135": {"description": "Reserved", "severity": "Warn"},
                        "136": {"description": "Reserved", "severity": "Warn"},
                        "137": {"description": "Reserved", "severity": "Warn"},
                        "138": {"description": "Reserved", "severity": "Warn"},
                        "139": {"description": "Reserved", "severity": "Warn"},
                        "140": {"description": "Unrecovered ECC Error", "severity": "Warn"},
                        "141": {"description": "Reserved", "severity": "Warn"},
                        "142": {"description": "Reserved", "severity": "Warn"},
                        "143": {"description": "GPU Initialization Failure", "severity": "Warn"}
                        }

            def check_gpu_xid(self):
                status = "Pass"
                dmesg_output = subprocess.check_output([self.dmesg_cmd]).decode("utf-8")
                if "NVRM: Xid" in dmesg_output:
                    for XID in self.XID_EC.keys():
                        logger.debug(f"Checking for GPU Xid {XID} error in dmesg")
                        
                        matches = re.findall(f"NVRM: Xid \(PCI:(.*?): {XID},", dmesg_output)
                        tmp_dict = {}
                        for match in matches:
                            if match not in tmp_dict:
                                tmp_dict[match] = 1
                            else:
                                tmp_dict[match] = tmp_dict[match] + 1
                        for x in tmp_dict.keys():
                            logger.info(f"{XID} : count: {tmp_dict[x]}, {self.XID_EC[XID]['description']} - PCI: {x}")
                        if not matches:
                            logger.debug(f"No GPU Xid {XID} error found in dmesg")
                        if tmp_dict != {}:
                            if self.XID_EC[XID]['severity'] == "Critical":
                                status = "Failed"
                            self.results[XID] = {"results": tmp_dict, "description": self.XID_EC[XID]['description']}
                else:
                    logger.info("Xid Check: Passed")
                return {"status": status, "results": self.results}


        if __name__ == '__main__':
            # Argument parsing
            parser = argparse.ArgumentParser(description='Check for GPU Xid errors.')
            parser.add_argument('--dmesg_cmd', default='dmesg', help='Dmesg file to check. Default is dmesg.')
            args = parser.parse_args()


            logger.debug(f"Using dmesg command: {args.dmesg_cmd}")
            
            xc = XidChecker(dmesg_cmd=args.dmesg_cmd)
            results = xc.check_gpu_xid()
            logger.debug("Status: {}, Results: {}".format(results["status"], results["results"]))

    shared_logging.py: |
        #!/usr/bin/env python3

        import logging
        logging.basicConfig(level="INFO", format='%(asctime)s - %(levelname)s - %(message)s')
        logger = logging.getLogger('nhc')

    oke_healthcheck.sh: |
        #!/bin/bash
        
        readonly OK=0
        readonly NONOK=1
        readonly UNKNOWN=2
        
        healthcheck_type=$1
        healtcheck_log_file=/host/tmp/oke-latest-${healthcheck_type}-healthcheck.log
        shape=$(chroot /host bash -c 'curl -sH "Authorization: Bearer Oracle" -L http://169.254.169.254/opc/v2/instance/shape')

        cp ./custom-config/*.py /host/tmp

        # Check if OCA RDMA config & auth plugins are enabled
        if chroot /host bash -c '/tmp/oke_healthcheck.py --oca-rdma-plugin-status 2>&1 | grep -q "OCA RDMA Plugins are enabled"'; then
            is_rdma_enabled=1
        else
            is_rdma_enabled=0
        fi        
        
        # If OCA RDMA plugins are not enabled, do not run the RDMA related tests
        if [ $is_rdma_enabled -ne 1 ] && ([ $healthcheck_type = "rdma-link" ] || [ $healthcheck_type = "rdma-link-flapping" ] || [ $healthcheck_type = "rdma-wpa-auth" ] || [ $healthcheck_type = "rdma-rttcc" ])
        then
            echo "Instance is not RDMA enabled"
            exit $UNKNOWN
        else
            chroot /host bash -c "/tmp/oke_healthcheck.py --short --$healthcheck_type > /tmp/oke-latest-${healthcheck_type}-healthcheck.log 2>&1"
        fi
        
        # Some GPU checks are not available on AMD shapes yet
        if [ $shape = "BM.GPU.MI300X.8" ] && ([ $healthcheck_type = "gpu-ecc" ] || [ $healthcheck_type = "gpu-bus" ] || [ $healthcheck_type = "gpu-remap" ])
        then
            echo "Healtcheck is not available on $shape shape"
            exit $UNKNOWN
        else
            chroot /host bash -c "/tmp/oke_healthcheck.py --short --$healthcheck_type > /tmp/oke-latest-${healthcheck_type}-healthcheck.log 2>&1"            
        fi
        
        ERROR_MSG=$(cat "$healtcheck_log_file" | grep "Healthcheck::")
        UNKNOWN_MSG=$(cat "$healtcheck_log_file" | grep -o 'Skipping.*')
        
        if [ "$ERROR_MSG" != "" ]
        then
            echo "${ERROR_MSG#* }"
            exit $NONOK
        elif [ "$ERROR_MSG" == "" ] && [ "$UNKNOWN_MSG" != "" ]
        then
            echo $UNKNOWN_MSG
            exit $UNKNOWN
        else
            echo "No errors found"
            exit $OK
        fi    

  log_monitors:
    - /config/kernel-monitor.json
    - /config/docker-monitor.json
    - /config/readonly-monitor.json
    # An example of activating a custom log monitor definition in
    # Node Problem Detector
    # - /custom-config/docker-monitor-filelog.json
  custom_plugin_monitors:
    - /custom-config/oke-gpu-ecc.json
    - /custom-config/oke-gpu-remap.json
    - /custom-config/oke-gpu-bus.json
    - /custom-config/oke-gpu-count.json
    - /custom-config/oke-rdma-link.json
    - /custom-config/oke-rdma-link-flapping.json
    - /custom-config/oke-rdma-wpa-auth.json
    - /custom-config/oke-rdma-rttcc.json
    - /custom-config/oke-oca-version.json

  # Any extra arguments to append to node-problem-detector command
  # - "--port 20526"
  extraArgs: []

  # settings.prometheus_address -- Prometheus exporter address
  prometheus_address: 0.0.0.0
  # settings.prometheus_port -- Prometheus exporter port
  prometheus_port: 20257

  # The period at which k8s-exporter does forcibly sync with apiserver
  # settings.heartBeatPeriod -- Syncing interval with API server
  heartBeatPeriod: 5m0s

logDir:
  # logDir.host -- log directory on k8s host
  host: /var/log/
  # logDir.pod -- log directory in pod (volume mount), use logDir.host if empty
  pod: ""

image:
  repository: registry.k8s.io/node-problem-detector/node-problem-detector
  tag: v0.8.20
  # image.digest -- the image digest. If given it takes precedence over a given tag.
  digest: ""
  pullPolicy: IfNotPresent

imagePullSecrets: []

nameOverride: ""
fullnameOverride: "gpu-rdma-node-problem-detector"

rbac:
  create: true
  pspEnabled: false

# hostNetwork -- Run pod on host network
# Flag to run Node Problem Detector on the host's network. This is typically
# not recommended, but may be useful for certain use cases.
hostNetwork: false
hostPID: false

volume:
  localtime:
    type: "FileOrCreate"

priorityClassName: system-node-critical

securityContext:
  privileged: true

resources: {}

annotations: {}

labels: {}

tolerations:
  - effect: NoSchedule
    operator: Exists

serviceAccount:
  # Specifies whether a ServiceAccount should be created
  create: true
  # Annotations to add to the service account
  annotations: {}
  # Labels to add to the service account
  labels: {}
  # The name of the ServiceAccount to use.
  # If not set and create is true, a name is generated using the fullname template
  name:

affinity:
  nodeAffinity:
    requiredDuringSchedulingIgnoredDuringExecution:
      nodeSelectorTerms:
        - matchExpressions:
            - key: node.kubernetes.io/instance-type
              operator: In
              values:
              - BM.GPU.A100-v2.8
              - BM.GPU.B4.8
              - BM.GPU4.8
              - BM.GPU.H100.8
              - BM.GPU.MI300X.8
              - BM.GPU.L40S-NC.4
              - BM.GPU.A10.4
              - VM.GPU.A10.1
              - VM.GPU.A10.2
              - VM.GPU.A100.80G.1

nodeSelector: {}

metrics:
  # metrics.enabled -- Expose metrics in Prometheus format with default configuration.
  enabled: false
  # metrics.annotations -- Override all default annotations when `metrics.enabled=true` with specified values.
  annotations: {}
  serviceMonitor:
    enabled: false
    additionalLabels: {}
    additionalRelabelings: []
    metricRelabelings: []
  prometheusRule:
    enabled: false
    defaultRules:
      create: true
      disabled: []
    additionalLabels: {}
    additionalRules: []

# env:
# - name: POOL_MODE
#   valueFrom:
#     fieldRef:
#       fieldPath: metadata.labels['oke.oraclecloud.com/pool.mode']

extraVolumes:
  - name: root
    hostPath:
      path: /

extraVolumeMounts:
  - name: root
    mountPath: /host

extraContainers: []

# updateStrategy -- Manage the daemonset update strategy
updateStrategy: RollingUpdate
# maxUnavailable -- The max pods unavailable during an update
maxUnavailable: 1